<!doctype html><html lang=cn><head><title>Unreal 骨骼动画入门（一） ::
简易现代魔法 — Zhirui Li's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="在这篇文章中，我们将从零开始学习 UE 的骨骼动画基本使用方法，通过一个 demo 工程，演示如何利用 UE 提供的骨骼动画能力来实现角色在不同速度和方向下的移动"><meta name=keywords content="编程,计算机图形学,游戏开发"><meta name=robots content="noodp"><link rel=canonical href=/posts/unreal-skeletal-animation-1/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon.png><link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="Unreal 骨骼动画入门（一）"><meta name=twitter:description content="UE4 骨骼动画学习笔记。"><meta property="og:title" content="Unreal 骨骼动画入门（一）"><meta property="og:description" content="UE4 骨骼动画学习笔记。"><meta property="og:type" content="article"><meta property="og:url" content="/posts/unreal-skeletal-animation-1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-08T00:00:00+00:00"><meta property="article:modified_time" content="2022-05-08T00:00:00+00:00"><meta property="og:site_name" content="简易现代魔法"><script>var posts=document.getElementById("posts-list");posts&&quicklink({el:posts,priority:!0})</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>简易现代魔法</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/archive>Archive</a></li><li><a href=/tags>Tags</a></li><li><a href=https://www.github.com/zhiruili>Github</a></li><li><a href=/index.xml>RSS</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/archive>Archive</a></li><li><a href=/tags>Tags</a></li><li><a href=https://www.github.com/zhiruili>Github</a></li><li><a href=/index.xml>RSS</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>Unreal 骨骼动画入门（一）</h1><div class=post-meta><span class=post-date>2022-05-08</span></div><span class=post-tags><a href=/tags/unreal/>#Unreal</a>&nbsp;
<a href=/tags/animation/>#Animation</a>&nbsp;</span><div class=post-content><p>在这篇文章中，我们将从零开始学习 UE 的骨骼动画基本使用方法，通过一个 demo 工程，演示如何利用 UE 提供的骨骼动画能力来实现角色在不同速度和方向下的移动效果。</p><h2 id=新建-demo-工程>新建 Demo 工程
<a href=#%e6%96%b0%e5%bb%ba-demo-%e5%b7%a5%e7%a8%8b class=h-anchor aria-hidden=true>#</a></h2><p>运行 UE，新建一个工程，这里简单使用了「Third Person」模板并命名为 UeAnim。新建完成后，导入模型和动画资源，这里使用了 UE 官方的「Animation Starter Pack」，它可以在 UE 的 marketplace 中找到：</p><p><img src=/images/2022-05-08-15-32-14.png alt></p><p>导入后，目录结构如下：</p><p><img src=/images/2022-05-08-15-36-33.png alt></p><p>接下来删除 viewport 中的原始角色，并修改 <code>Source/UeAnim/UeAnimGameMode.cpp</code> 中的 <code>DefaultPawnClass</code> 对应的蓝图，我们之后不会用到原始的资源：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>AUeAnimGameMode<span style=color:#f92672>::</span>AUeAnimGameMode() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> ConstructorHelpers<span style=color:#f92672>::</span>FClassFinder<span style=color:#f92672>&lt;</span>APawn<span style=color:#f92672>&gt;</span> PlayerPawnBPClass(TEXT(<span style=color:#e6db74>&#34;/Game/AnimStarterPack/Ue4ASP_Character&#34;</span>));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (PlayerPawnBPClass.Class <span style=color:#f92672>!=</span> NULL) {
</span></span><span style=display:flex><span>        DefaultPawnClass <span style=color:#f92672>=</span> PlayerPawnBPClass.Class;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>编译代码，并将「World Settings」中的「GameMode Override」修改为对应的 game mode，这里是 <code>UeAnimGameMode</code> ：</p><p><img src=/images/2022-05-08-15-38-23.png alt></p><p>此时点击「Play」按钮，可以看到场景中出现了「Animation Starter Pack」里的模型：</p><p><img src=/images/2022-05-08-15-40-18.png alt></p><h2 id=资源类型说明>资源类型说明
<a href=#%e8%b5%84%e6%ba%90%e7%b1%bb%e5%9e%8b%e8%af%b4%e6%98%8e class=h-anchor aria-hidden=true>#</a></h2><p>打开 <code>Content/AnimStarterPack/UE4_Mannequin/Mesh</code> 目录，可以看到三个资源：</p><p>紫红色资源 <strong>Skeletal Mesh</strong><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> <code>SK_Mannequin</code></p><p><img src=/images/2022-05-08-14-48-58.png alt></p><p>Skeletal Mesh 资源是骨骼动画要控制的目标。网格体 mesh 分为静态网格体 static mesh 和骨骼网格体 skeletal mesh 两种，两者的区别在于 skeletal mesh 可以被动画化，因为它具有和骨骼的绑定关系，通过移动骨骼可以实现对它的变形。这里需要提到一个「蒙皮」概念，蒙皮是指把 mesh 的顶点绑定到骨骼上，并且每个顶点可以被多个骨骼按一定权重进行控制。需要注意的是蒙皮是一个容易让人误解的词，这里的「皮」不是指贴图，而是 mesh 本身。</p><p>也就是说，我们看到 skeletal mesh 的动画并不是动画师直接操作 mesh 顶点实现的，而是通过操作骨骼实现的。而骨骼的定义则是通过下面要说的 Skeleton 资源实现。</p><p>青色资源 <strong>Skeleton</strong><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> <code>SK_Mannequin_Skeleton</code></p><p><img src=/images/2022-05-08-14-49-43.png alt></p><p>Skeleton 资源是整个动画系统的基础，它是一组相互连接结构化排布的骨骼，我们可以通过改变骨骼的朝向和位置来生成动画。「骨骼」也是一个容易被误解的词，因为动画师控制的其实不是「骨骼」而是「关节」，「骨骼」是「关节」之间的空位，因此事实上一般提到「骨骼」都是指「关节」。</p><p>橘黄色资源 <strong>Physis Asset</strong><sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> <code>SK_Mannequin_PhysicsAsset</code></p><p><img src=/images/2022-05-08-14-50-25.png alt></p><p>Physis Asset 用于定义该模型使用的物理和碰撞信息。</p><p>在上两层目录，即 <code>Content/AnimStarterPack</code> 中有许多资源文件，这些都是动画相关的文件，其中：</p><p>绿色资源 <strong>Animation Sequence</strong><sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> 如 <code>Aim_Space_Hip</code></p><p><img src=/images/2022-05-08-14-47-51.png alt></p><p>Animation Sequence 是可在骨架网格体上播放的单个动画资源，记录骨骼随时间的运动状态信息，也就是定义了动画。需要注意的是，每个 animation sequence 资源专门针对特定的 skeleton，且只能在这个 skeleton
上播放，为了能在多个 skeletal mesh 上共享动画，它们必须要使用同一个 skeleton 资源。</p><p>蓝色资源 <strong>Blueprint Class</strong><sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> <code>Ue4ASP_Character</code></p><p><img src=/images/2022-05-08-14-47-17.png alt></p><p>Blueprint 是 UE 中的可视化脚本，可以通过拖拽节点的方式构建游戏逻辑。</p><p>褐色资源 <strong>Animation Blueprint</strong><sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> <code>UE4ASP_HeroTPP_AnimBlueprint</code></p><p><img src=/images/2022-05-14-16-35-13.png alt></p><p>Animation Blueprint
资源和一般的蓝图类似，也是可视化脚本，可用于创建和控制动画行为。前面的
animation sequence
资源仅定义了动画本身，并不记录何时播放以及如何播放的信息，我们需要通过
animation blueprint 对动画播放进行控制。</p><p>橙色资源 <strong>Blend Space</strong><sup id=fnref1:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> 如 <code>BS_CrouchWalk</code></p><p><img src=/images/2022-05-08-15-04-16.png alt></p><p>Blend Space 资源可以根据多个输入的值混合 animation sequence，创建出多个动画间的过渡效果。</p><h2 id=动画混合>动画混合
<a href=#%e5%8a%a8%e7%94%bb%e6%b7%b7%e5%90%88 class=h-anchor aria-hidden=true>#</a></h2><p>一般来说，UE 本身不用于制作动画，我们仅会去导入并使用动画资源，例如控制一个角色何时播放哪些动画，动画之间如何切换等，或在其上进行微调。模型和动画资源是由美术使用类似 Maya 之类的工具制作的。我们拿到这些动画资源并导入后，可以双击 animation sequence 资源打开 animation editor 查看单个动画的预览效果：</p><p><img src=/images/ue_animation_editor_preview.gif alt></p><p>在使用这些动画之前，我们需要先实现在多个动画之间的平滑切换。例如，我们想实现一个角色从静止逐步加速，先变为走路，再加速到跑步的效果，我们不会对这个过程中每一个速度值都设计一个动画，而会设计静止、走路、跑步三个动画，分别对应于角色移动速度为 0、1.5m/s、3m/s 时的状态，这之间的其他速度值就用这几个动画混合生成。我们可以用前面提到的 blend space 来定义这个生成逻辑。Blend space 有两种，一种是普通的 blend
space，另一种是 blend space 1D，其中 blend space 的混合参数值有两个，blend space 1D 的混合。这里以 blend space 为例说明，在 Content Browser 中新建一个 blend space 资源：</p><p><img src=/images/2022-05-08-15-26-12.png alt></p><p>前面提到，每个骨骼动画都是专门针对特定的 skeleton 实现的，因此 blend space 显然也需要针对特定 skeleton 实现。UE 会在创建 blend space 的时候要求我们指明对应的 skelton 资源，这里选择
<code>AnimStarterPack</code> 目录下的 skeleton：</p><p><img src=/images/2022-05-08-16-09-32.png alt></p><p>双击这个这个资源后，我们可以在 Animation Editor 中编辑 blend space：</p><p><img src=/images/2022-05-08-16-20-50.png alt></p><p>在 blend space 中，我们可以根据两个参数的值来确定动画的混合逻辑，在 editor 的下方可以看到一个二维的坐标系，两个参数分别对应两个坐标轴，拖动绿点可以在上方查看混合的效果：</p><p><img src=/images/2022-05-08-16-28-06.png alt></p><p>这里坐标轴的对应的名字和其变化范围可以在左侧的「Asset Details」中设置，这里将 x 轴设为方向，取值为 -90～90，y 轴设为移动速度，取值为 0～300：</p><p><img src=/images/2022-05-08-16-33-20.png alt></p><p>然后，将左侧的 Asset Browser 面板中的动画资源拖动到坐标系中对应的位置，例如当旋转 0 度，速度为 0 的时候是 idle 动画，那么就将 idle 动画拖到 direction 为 0 且 speed 为 0 的位置上：</p><p><img src=/images/2022-05-08-16-57-47.png alt></p><p>类似地，我们可以将向左走路动画放在 direction 为 -90 speed 为 150 的位置，向右跑步的动画放在 direction 为 90 speed 为 300 的位置&mldr;&mldr;将这些动画放好后，我们可以拖动绿点进行预览：</p><p><img src=/images/ue_animation_editor_blend_space.gif alt></p><h2 id=动画控制>动画控制
<a href=#%e5%8a%a8%e7%94%bb%e6%8e%a7%e5%88%b6 class=h-anchor aria-hidden=true>#</a></h2><p>为了使用动画，我们需要动画播放的控制器，前面提到，UE 通过 animation blueprint 控制动画行为。在 Content Browser 中新建一个 animation blueprint 资源，命名为 <code>BP_Anim</code> ，这里同样要指定使用 <code>AnimStarterPack</code> 目录下的 skeleton：</p><p><img src=/images/2022-05-08-17-17-12.png alt></p><p>双击打开新建的 blueprint 进入 Animation Blueprint Editor，可以看到中间有两个 tab，一个是 Event Graph 一个是 AnimGraph：</p><p><img src=/images/2022-05-08-18-25-38.png alt></p><p>默认情况下，AnimGraph 中只有一个「Output Pose」节点，我们可以将任意动画从右侧的 Asset Browser 面板中拖入 AnimGraph 里，然后将动画的输出连到 Output Pose 节点的输入上：</p><p><img src=/images/2022-05-08-18-37-35.png alt></p><p>此时点击「Compile」按钮，会发现动画节点和 Output Pose 节点之间的连线亮起，在预览面板中可以看到动画播放的效果：</p><p><img src=/images/2022-05-08-18-38-56.png alt></p><p>但这样的连接并不能实现状态的转换，例如在点击蹲下后将角色动画切到蹲下的动画。在 animation blueprint
中，我们通过状态机来实现这样的转换功能。删除刚刚添加的动画节点，然后右键添加一个 State Machine 节点，并将其输出连接到 Output Pose 的输入上：</p><p><img src=/images/2022-05-08-20-21-27.png alt></p><p>双击新增的 State Machine 节点，进入该节点的编辑界面，如果需要返回刚刚的 AnimGraph 界面，可以点击顶部的「AnimGraph」。默认情况下，这里只有一个「Entry」节点，我们拖动这个节点的输出，可以新增节点，这里新增一个 State 节点：</p><p><img src=/images/2022-05-08-20-23-31.png alt></p><p>将这个 state 节点命名为 Normal，这个节点用于表示通常状态下的动画。双击这个节点，进入这个 Normal 节点的编辑界面，我们可以看到和之前 Output Pose 类似的一个动画输出节点 Output Animation Pose。此时我们可以从左侧的 Asset Browser 面板中拖出之前的 blend space 资源，并将其输出连接到 Output Animation Pose 的输入上：</p><p><img src=/images/2022-05-08-20-40-37.png alt></p><p>问题是我们的 blend space 需要当前的方向和速度作为输入，这个数据又要从哪来呢？我们可以点击上方的 Event Graph tab，切换到事件编辑界面：</p><p><img src=/images/2022-05-08-20-45-55.png alt></p><p>在右下方的 My Blueprint 面板中找到「Variable」session，添加两个 <code>float</code> 类型的变量，命名为 <code>Speed</code> 和 <code>Direction</code> 用于表示速度和方向：</p><p><img src=/images/2022-05-08-20-56-35.png alt></p><p>接下来，我们需要设置这两个变量，首先，新建一个 Get Player Character 节点，并将其类型转换到我们使用的 character 类型上，这里是 <code>Ue4ASP_Character</code> 。从这个节点出发，获取其 Velocity 并计算其长度，这个就是角色当前的速度值，将这个值设给 <code>Speed</code> 变量。然后，通过 Calculate Direction 节点获取当前方向，并赋值给 <code>Direction</code> 变量，大致如下图所示：</p><p><img src=/images/2022-05-08-21-06-18.png alt></p><p>此时我们可以回到 Normal 节点的编辑界面，将 <code>Speed</code> 和 <code>Direction</code> 两个变量赋值给 blend space
的对应位置。编译后，我们可以在左侧「Anim Preview」面板中输入不同的速度和方向值，就可以在左侧的预览面板中看到具体效果：</p><p><img src=/images/2022-05-08-21-16-00.png alt></p><p>目前我们的状态机只有一个状态，我们可以添加更多状态并定义状态之间的转换规则。回到之前的 state machine 编辑界面，从 Normal 节点出发再拖一个节点出来，命名为 Crouch，这个节点用于表示下蹲状态下的动画。此时我们发现 Normal 和 Crouch 之间有一个绘制了双向箭头的圆圈，这个是用于表示两个状态之间的转换规则。由于我们之前是从 Normal 节点出发添加的 Crouch 节点，因此 UE 自动建立了 Normal 到 Crouch 的转换，为了将状态转回去，这里从 Crouch 节点出发，将箭头指向 Normal 节点：</p><p><img src=/images/2022-05-08-21-25-09.png alt></p><p>为了标记角色是否是蹲下状态，我们添加一个 <code>bool</code> 变量，命名为 <code>Crouched</code> 并从 character blueprint 中获取 <code>IsCrouched</code> 的值，并赋值给它：</p><p><img src=/images/2022-05-11-20-33-26.png alt></p><p>如果我们需要用该蓝图没有提供的状态，那么就需要去该 character 蓝图中自行添加，然后再在此处获取。</p><p>回到 state machine 编辑界面，双击从 Normal 到 Crouch 的转换规则圆圈，进入转换规则编辑界面，将 <code>Crouched</code> 变量的值赋给 Result 节点：</p><p><img src=/images/2022-05-08-21-52-33.png alt></p><p>类似地，在 Crouch 到 Normal 的转换规则中，将 not <code>Crouched</code> 的值赋给 Result 节点：</p><p><img src=/images/2022-05-08-21-55-32.png alt></p><p>而在 Crouch 状态中，我们也给 Output Animation Pose 输入一个动画，这里就不重复 blend space 的制作了，简单将一个 idle 的蹲下动画作为输入：</p><p><img src=/images/2022-05-08-21-58-34.png alt></p><p>此时可以修改 Anim Preview 面板中的数值来预览动画状态改变的效果了：</p><p><img src=/images/ue_animation_state_machine_preview.gif alt></p><h2 id=应用动画>应用动画
<a href=#%e5%ba%94%e7%94%a8%e5%8a%a8%e7%94%bb class=h-anchor aria-hidden=true>#</a></h2><p>在制作好前面的动画后，我们可以打开 <code>Ue4ASP_Character</code> 蓝图，在 Viewport 面板中选中我们的角色模型，然后在右侧的 Details 面板中找到 Animation 一节，将其中的「Animation Mode」改为「Use Animation Blueprint」，再将「Anim Class」改为刚刚制作的动画 <code>BP_Anim</code> ：</p><p><img src=/images/2022-05-11-20-15-34.png alt></p><p>另外，为了实现蹲下的能力，我们还需要做几处修改。首先在 <code>Ue4ASP_Character</code> 蓝图中间的 Event Graph 中找到 Crouching 组，在这里修改蓝图逻辑来触发角色的蹲下状态。简单起见，这里不作复杂判断，直接在 Crouch Button Down 为 <code>true</code> 的时候触发蹲下， <code>false</code> 的时候解除蹲下：</p><p><img src=/images/2022-05-11-20-52-25.png alt></p><p>然后，我们在左侧的 Components 面板中选中 Character Movement 一项，在右侧的 Details 面板中找到 Nav Movement 一节，勾选其中的「Can Crouch」，确保可以蹲下：</p><p><img src=/images/2022-05-11-20-43-55.png alt></p><p>修改好后保存更改并编译。最后，在菜单栏的 Edit 菜单下点击「Project Settings&mldr;」，然后在 Input 菜单中的 Action Mappings 列表里加一项「Crouch」，并绑定一个按键，这里绑定的是左 Ctrl 键：</p><p><img src=/images/2022-05-11-20-24-20.png alt></p><p>回到主界面，点击「Play」运行游戏，就可以用 WASD 键控制方向，用左 Ctrl 蹲下，查看动画效果了：</p><p><img src=/images/ue_animation_play_in_game.gif alt></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://docs.unrealengine.com/4.27/zh-CN/WorkingWithContent/Types/SkeletalMeshes/>骨架网格体 | 虚幻引擎文档</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://docs.unrealengine.com/4.27/zh-CN/AnimatingObjects/SkeletalMeshAnimation/Skeleton/>骨架资源 | 虚幻引擎文档</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://docs.unrealengine.com/4.27/zh-CN/InteractiveExperiences/Physics/PhysicsAssetEditor/>物理资产编辑器 | 虚幻引擎文档</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://docs.unrealengine.com/4.27/zh-CN/AnimatingObjects/SkeletalMeshAnimation/Sequences/>动画序列 | 虚幻引擎文档</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://docs.unrealengine.com/4.27/zh-CN/AnimatingObjects/SkeletalMeshAnimation/AnimBlueprints/>动画蓝图 | 虚幻引擎文档</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><a href=https://docs.unrealengine.com/4.27/zh-CN/AnimatingObjects/SkeletalMeshAnimation/Blendspaces/>混合空间 | 虚幻引擎文档</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a>&#160;<a href=#fnref1:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/unreal-skeletal-animation-2/><span class=button__icon>←</span>
<span class=button__text>Unreal 骨骼动画入门（二）</span></a></span>
<span class="button next"><a href=/posts/rbf-interpolation/><span class=button__text>RBF 插值的理论与应用</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><p>本网站采用 <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a> 协议进行授权</p><p>© 2023 Zhirui Li. All rights reserved.</p></div></div></footer><script src=/assets/main.js></script>
<script src=/assets/prism.js></script></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-80302213-1","auto"),ga("send","pageview"))</script></body></html>