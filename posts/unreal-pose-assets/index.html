<!doctype html><html lang=cn><head><title>Unreal 基于 PoseAsset 捏人 ::
简易现代魔法 — Zhirui Li's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="概述 # PoseAsset 是 UE 提供的一种基于曲线驱动动画的方式 1。传统动画使用关键帧来控制，关键帧之间的状态计算使用前后关键帧状态插值来实现，而 PoseAsset 则是通过定义"><meta name=keywords content="编程,计算机图形学,游戏开发"><meta name=robots content="noodp"><link rel=canonical href=/posts/unreal-pose-assets/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon.png><link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="Unreal 基于 PoseAsset 捏人"><meta name=twitter:description content="本文讨论了如何在 UE 中使用 PoseAsset 实现捏人功能，并进一步优化工作流。"><meta property="og:title" content="Unreal 基于 PoseAsset 捏人"><meta property="og:description" content="本文讨论了如何在 UE 中使用 PoseAsset 实现捏人功能，并进一步优化工作流。"><meta property="og:type" content="article"><meta property="og:url" content="/posts/unreal-pose-assets/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-15T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-15T00:00:00+00:00"><meta property="og:site_name" content="简易现代魔法"><script>var posts=document.getElementById("posts-list");posts&&quicklink({el:posts,priority:!0})</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>简易现代魔法</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/archive>Archive</a></li><li><a href=/tags>Tags</a></li><li><a href=https://www.github.com/zhiruili>Github</a></li><li><a href=/index.xml>RSS</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/archive>Archive</a></li><li><a href=/tags>Tags</a></li><li><a href=https://www.github.com/zhiruili>Github</a></li><li><a href=/index.xml>RSS</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>Unreal 基于 PoseAsset 捏人</h1><div class=post-meta><span class=post-date>2022-08-15</span></div><span class=post-tags><a href=/tags/unreal/>#Unreal</a>&nbsp;
<a href=/tags/animation/>#Animation</a>&nbsp;</span><div class=post-content><h2 id=概述>概述
<a href=#%e6%a6%82%e8%bf%b0 class=h-anchor aria-hidden=true>#</a></h2><p>PoseAsset 是 UE 提供的一种基于曲线驱动动画的方式 <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。传统动画使用关键帧来控制，关键帧之间的状态计算使用前后关键帧状态插值来实现，而 PoseAsset 则是通过定义动画的极值，然后对这些极值进行加权来组合出动画。比如先定义眼睛睁开到最大和闭合的状态，然后，通过曲线控制它们的权重，实现眨眼的效果。一个常见的应用场景就是基于 FACS <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> 实现面部表情。而这个能力也非常适合用于进行游戏中常见的捏人操作，在本文中我们将会讨论如何在 UE 中使用 PoseAsset 实现捏人功能，并进一步优化工作流。</p><h2 id=基础使用>基础使用
<a href=#%e5%9f%ba%e7%a1%80%e4%bd%bf%e7%94%a8 class=h-anchor aria-hidden=true>#</a></h2><p>在美术制作好 PoseAsset 资源后，将其以动画骨骼动画的形式导出为 FBX 文件，然后导入 UE 之中，打开这个动画资产，我们大致能看到这样无意义的动画：</p><p><img src=/images/ue_pose_assets_raw_anim.gif alt></p><p>一般来说，这里动画的第一帧是参考体型，之后每一帧都有具体的含义，代表某一个捏人参数的极值，因此我们可以看到上图中模型各个部位会逐个发生形状变化。在导入了这个动画后，右键点击该动画资产，选择「Create」-「Create PoseAsset」创建一个 PoseAsset：</p><p><img src=/images/ue_pose_assets_convert_menu.png alt></p><p>此时 UE 会弹出创建 PoseAsset 的提示，窗口上面选择使用的动画，下面则填入这个动画序列每一帧代表的含义。如果不填的话，引擎就只能给它默认的无意义的名字，不直观也不方便后续操作。一般来说这个名字列表需要由 PoseAsset 资源的制作者提供：</p><p><img src=/images/ue_pose_assets_convert_window.png alt></p><p>创建好 PoseAsset 后，一般我们还会将其模式改为叠加模式，以方便它和其他动画组合使用。双击这个资产打开编辑窗口，找到「Asset Details」面板，将这里的「Additive」选项勾上，然后点「Convert to Additive Pose」按钮即可：</p><p><img src=/images/ue_pose_assets_set_additive.png alt></p><p>在这个资产编辑窗口中我们可以看到刚刚填入的每一帧对应的名字，此时可以随意调整其数值预览它产生的效果，例如下图中将「upperLegStrong_L」的值改到 1，就看到模型左腿上部变粗了：</p><p><img src=/images/ue_pose_assets_curve_preview.png alt></p><p>这些 pose 的名字也绑定于对应的动画曲线名，在「Anim Curves」面板中我们可以看到这些曲线。显然，由于动画曲线和骨架绑定，因此 pose 名需要在这个骨架内保证唯一：</p><p><img src=/images/ue_pose_assets_anim_curve.png alt></p><p>使用 PoseAsset 很简单，只需要在动画蓝图的输入节点和输出节点之间插入「Modify Curve」节点 <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> 和对应的 PoseAsset 节点即可，如下图所示：</p><p><img src=/images/ue_pose_assets_anim_bp_nodes.png alt></p><p>其中，「Modify Curve」节点就相当于刚刚在编辑窗口中手动调节每个曲线的值，这里的曲线值可以通过自行定义对应的动画蓝图变量来赋值：</p><p><img src=/images/ue_pose_assets_anim_bp_variables.png alt></p><p>接下来我们新建一个蓝图类，在上面挂载「USkeletalMeshComponent」，并使用前面的动画蓝图和对应的模型，并将「Animation Class」设定为前面的动画蓝图：</p><p><img src=/images/ue_pose_assets_bp_mesh.png alt></p><p>为了暴露动画蓝图的参数给游戏侧控制，我们还要在该蓝图中定义一组和动画蓝图中一一对应的变量：</p><p><img src=/images/ue_pose_assets_anim_bp_variables.png alt></p><p>回到动画蓝图的编辑界面，打开它的「Event Graph」，在其中对每一个动画蓝图中的变量进行赋值，变量值的来源就是刚刚在蓝图中定义的对应变量：</p><p><img src=/images/ue_pose_assets_anim_bp_assign.png alt></p><p>此时，我们就可以在场景中通过蓝图里的变量控制曲线值，进而进行捏人了：</p><p><img src=/images/ue_pose_assets_modify_curves.gif alt></p><h2 id=使用优化>使用优化
<a href=#%e4%bd%bf%e7%94%a8%e4%bc%98%e5%8c%96 class=h-anchor aria-hidden=true>#</a></h2><p>UE 自带的 PoseAsset 能力足够实现捏人的能力，但在实际应用的过程中还是不够方便。从上面的案例中也能看出，我们需要在蓝图和动画蓝图中定义一堆对应的变量，而且还需要手动连接非常多的引脚，这不仅麻烦而且没法配置化，我们在实际应用的时候一般希望能通过一个配置文件指定有哪些曲线可以编辑，然后在代码中按名字修改其数据，而不是在蓝图中连接一堆引脚。</p><p>为了实现这个功能，我们需要实现一个批量修改曲线的 anim node，这一块的文档不多，比较简单的方式是参考 UE 自己的实现，既然我们也是要修改曲线，那直接参考 UE 的 <code>FAnimNode_ModifyCurve</code> 类型 <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> 即可，大致声明如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 用于批量修改一组 pose 曲线的 anim node。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>USTRUCT(BlueprintInternalUseOnly)
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MY_API</span> FAnimNode_BatchModifyPoseCurve : <span style=color:#66d9ef>public</span> FAnimNode_Base {
</span></span><span style=display:flex><span>    GENERATED_USTRUCT_BODY()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    UPROPERTY(EditAnywhere, EditFixedSize, BlueprintReadWrite, Category <span style=color:#f92672>=</span> Links)
</span></span><span style=display:flex><span>    FPoseLink SourcePose;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>Evaluate_AnyThread</span>(FPoseContext<span style=color:#f92672>&amp;</span> Output) <span style=color:#66d9ef>override</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/** ... **/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// FNamedCurveValue 定义在 Animation/CurveSourceInterface.h 中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    TArray<span style=color:#f92672>&lt;</span>FNamedCurveValue<span style=color:#f92672>&gt;</span> CurveModifyData;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>其中，主要逻辑实现在 <code>Evaluate_AnyThread</code> 中，同样，设置曲线值的逻辑也可以参考 <code>FAnimNode_ModifyCurve::Evaluate_AnyThread</code> 的实现，大致如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>USkeleton <span style=color:#66d9ef>const</span><span style=color:#f92672>*</span> Skeleton <span style=color:#f92672>=</span> Output.AnimInstanceProxy<span style=color:#f92672>-&gt;</span>GetSkeleton();
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#66d9ef>const</span><span style=color:#f92672>&amp;</span> ModifyItem : CurveModifyData) {
</span></span><span style=display:flex><span>    SmartName<span style=color:#f92672>::</span>UID_Type <span style=color:#66d9ef>const</span> NameUID <span style=color:#f92672>=</span> Skeleton<span style=color:#f92672>-&gt;</span>GetUIDByName(USkeleton<span style=color:#f92672>::</span>AnimCurveMappingName, ModifyItem.Name);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>float</span> <span style=color:#66d9ef>const</span> CurrentValue <span style=color:#f92672>=</span> Output.Curve.Get(NameUID);
</span></span><span style=display:flex><span>    Output.Curve.Set(NameUID, CurrentValue <span style=color:#f92672>+</span> ModifyItem.Value);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>问题是这里的 <code>CurveModifyData</code> 中的值从哪来，一个做法是自己实现一个 anim instance 作为游戏逻辑和 anim node 之间的中介，在 anim node 中可以这样获取 anim instance：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>auto</span> AnimInst <span style=color:#f92672>=</span> Cast<span style=color:#f92672>&lt;</span>UMyAnimInstance<span style=color:#f92672>&gt;</span>(Output.AnimInstanceProxy<span style=color:#f92672>-&gt;</span>GetAnimInstanceObject());
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (AnimInst <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span> <span style=color:#f92672>&amp;&amp;</span> AnimInst<span style=color:#f92672>-&gt;</span>IsDirty()) {
</span></span><span style=display:flex><span>    CurveModifyData <span style=color:#f92672>=</span> AnimInst<span style=color:#f92672>-&gt;</span>GetPoseCurves();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>至于 <code>UMyAnimInstance</code> 则非常简单，主要功能就是设置和获取曲线数据，唯一一个需要注意的点是多线程操作数据记得加锁：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MY_API</span> UMyAnimInstance : <span style=color:#66d9ef>public</span> UAnimInstance {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 设置 pose 曲线数据。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    UFUNCTION(BlueprintCallable)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> SetPoseCurves(TArray<span style=color:#f92672>&lt;</span>FNamedCurveValue<span style=color:#f92672>&gt;</span> Data);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 数据是否被修改过。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>IsDirty</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取 pose 曲线数据。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    TArray<span style=color:#f92672>&lt;</span>FNamedCurveValue<span style=color:#f92672>&gt;</span> GetPoseCurves();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    TArray<span style=color:#f92672>&lt;</span>FNamedCurveValue<span style=color:#f92672>&gt;</span> PoseCurves;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> bDirty <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>mutable</span> FCriticalSection CriticalSection;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>在 UE 中，为了给动画蓝图编辑器提供节点信息，每个 anim node 还需要一个配套的 anim graph node，类似地，我们参考 <code>UAnimGraphNode_ModifyCurve</code> 来实现一个，这里的功能比 <code>UAnimGraphNode_ModifyCurve</code> 要简单很多，仅仅提供一些名字之类的信息，大致如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>UCLASS(MinimalAPI)
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UAnimGraphNode_BatchModifyPoseCurve</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> UAnimGraphNode_Base {
</span></span><span style=display:flex><span>    GENERATED_UCLASS_BODY()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    UPROPERTY(EditAnywhere, Category <span style=color:#f92672>=</span> Settings)
</span></span><span style=display:flex><span>    FAnimNode_BatchModifyPoseCurve BlendNode;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> FText <span style=color:#a6e22e>GetTooltipText</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>override</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> FText <span style=color:#a6e22e>GetNodeTitle</span>(ENodeTitleType<span style=color:#f92672>::</span>Type TitleType) <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>override</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> FString <span style=color:#a6e22e>GetNodeCategory</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>override</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>需要注意这个类型需要依赖一些 editor only 的模块，但是这个类所属的模块类型只能是只能是 <code>UncookedOnly</code> 而不可以是 <code>Editor</code> ，否则会有如下的报错：</p><blockquote><p>The node &rsquo; Batch Modify Pose Curve &rsquo; is from an Editor Only module, but is placed in a runtime blueprint! K2 Nodes should only be defined in a Developer or UncookedOnly module.</p></blockquote><p>错误信息里提到的 <code>Developer</code> 类型已经废弃了，因此我们选用 <code>UncookedOnly</code> 类型，即在配置中对其所在的模块进行类似这样的声明：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;FileVersion&#34;</span>: <span style=color:#ae81ff>3</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;Modules&#34;</span>: [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;Name&#34;</span>: <span style=color:#e6db74>&#34;DemoEditor&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;Type&#34;</span>: <span style=color:#e6db74>&#34;UncookedOnly&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#f92672>&#34;LoadingPhase&#34;</span>: <span style=color:#e6db74>&#34;Default&#34;</span>
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        <span style=color:#960050;background-color:#1e0010>...</span>
</span></span><span style=display:flex><span>    ],
</span></span><span style=display:flex><span>    <span style=color:#960050;background-color:#1e0010>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在实现了 anim node 和配套的 anim graph node 之后，我们就可以移除之前定义在动画蓝图中的所有变量，并将其 AnimGraph 改为这样：</p><p><img src=/images/ue_pose_assets_anim_bp_nodes_new.png alt></p><p>另外需要注意此时动画蓝图的父类需要设置为我们自己实现的 anim instance：</p><p><img src=/images/ue_pose_assets_anim_parent_class.png alt></p><p>这样一来我们就可以在代码中调用 <code>UMyAnimInstance::SetPoseCurves</code> 接口将数据批量设置进 anim node 中了，例如这样：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ApplyPoseCurvesToAnim</span>(USkeletalMeshComponent<span style=color:#f92672>*</span> SkeMeshComp, TArray<span style=color:#f92672>&lt;</span>FNamedCurveValue<span style=color:#f92672>&gt;</span> Curves) {
</span></span><span style=display:flex><span>    UMyAnimInstance<span style=color:#f92672>*</span> AnimInstance <span style=color:#f92672>=</span> Cast<span style=color:#f92672>&lt;</span>UMyAnimInstance<span style=color:#f92672>&gt;</span>(SkeMeshComp<span style=color:#f92672>-&gt;</span>GetAnimInstance());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (AnimInstance <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>        AnimInstance<span style=color:#f92672>-&gt;</span>SetPoseCurves(std<span style=color:#f92672>::</span>move(Curves));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=与-controlrig-结合使用>与 ControlRig 结合使用
<a href=#%e4%b8%8e-controlrig-%e7%bb%93%e5%90%88%e4%bd%bf%e7%94%a8 class=h-anchor aria-hidden=true>#</a></h2><p>ControlRig <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> 是 UE 提供的一种约束骨骼移动的方案，也常被用于实现捏脸功能，相比直接使用 PoseAsset，使用 ControlRig 可以添加一些约束信息来实现避免表情穿帮的效果。虽然连接的节点和 PoseAsset 不同，但在用户控制界面上，基于 ControlRig 进行捏脸其实还是操作曲线，因此也可以复用前面我们开发的逻辑。类似这样连接节点即可：</p><p><img src=/images/ue_pose_assets_anim_bp_nodes_ctrl_rig.png alt></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://docs.unrealengine.com/4.27/zh-CN/AnimatingObjects/SkeletalMeshAnimation/AnimPose/>动画姿势资源 | 虚幻引擎文档</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://en.wikipedia.org/wiki/Facial_Action_Coding_System>Facial Action Coding System - Wikipedia</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://docs.unrealengine.com/4.27/zh-CN/AnimatingObjects/SkeletalMeshAnimation/NodeReference/SkeletalControls/ModifyCurve/>修改曲线（Modify Curve） | 虚幻引擎文档</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://docs.unrealengine.com/4.27/en-US/API/Runtime/AnimGraphRuntime/AnimNodes/FAnimNode_ModifyCurve/>FAnimNode_ModifyCurve | Unreal Engine Documentation</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://docs.unrealengine.com/4.27/zh-CN/AnimatingObjects/SkeletalMeshAnimation/ControlRig/>Control Rig | 虚幻引擎文档</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/posts/unreal-slate-ui/><span class=button__icon>←</span>
<span class=button__text>Unreal Slate UI 的使用</span></a></span>
<span class="button next"><a href=/posts/unreal-skeletal-animation-2/><span class=button__text>Unreal 骨骼动画入门（二）</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><p>本网站采用 <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a> 协议进行授权</p><p>© 2021 Zhirui Li. All rights reserved.</p></div></div></footer><script src=/assets/main.js></script>
<script src=/assets/prism.js></script><p style=color:#999>我的博客即将同步至腾讯云+社区，<a target=_blank href="https://cloud.tencent.com/developer/support-plan?invite_code=11dehb9vzutlx">邀请大家一同入驻</a>。</p></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-80302213-1","auto"),ga("send","pageview"))</script></body></html>