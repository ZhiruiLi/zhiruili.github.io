<!doctype html><html lang=cn>
<head>
<title>
使用 Future 进行并发编程 ::
简单易懂的现代魔法 — Zhirui Li's Blog
</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Future 的概念 在编程的时候，常常会遇到需要并行处理一些代码，最原始的做法就是创建不同的线程进行处理，但是线程之间的同步处理非常麻烦而且容易出错，如">
<meta name=keywords content="编程,计算机图形学,游戏开发">
<meta name=robots content="noodp">
<link rel=canonical href=/posts/handle-concurrency-using-future/>
<link rel=stylesheet href=/assets/style.css>
<link rel=stylesheet href=/style.css>
<link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png>
<link rel="shortcut icon" href=/img/favicon.png>
<link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="使用 Future 进行并发编程">
<meta name=twitter:description content="Future 能够将计算任务的并发化和计算最终的执行方式分离，通过一套设计良好的 API 使得对数据的操作变得简单。">
<meta property="og:title" content="使用 Future 进行并发编程">
<meta property="og:description" content="Future 能够将计算任务的并发化和计算最终的执行方式分离，通过一套设计良好的 API 使得对数据的操作变得简单。">
<meta property="og:type" content="article">
<meta property="og:url" content="/posts/handle-concurrency-using-future/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2016-08-27T00:00:00+00:00">
<meta property="article:modified_time" content="2016-08-28T00:00:00+00:00"><meta property="og:site_name" content="简单易懂的现代魔法">
<script>var posts=document.getElementById('posts-list');posts&&quicklink({el:posts,priority:!0})</script>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
</head>
<body>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ class=logo style=text-decoration:none>
<span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span>
<span class=logo__text>简单易懂的现代魔法</span>
<span class=logo__cursor></span>
</a>
<span class=header__right>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/archive>Archive</a></li>
<li><a href=https://www.github.com/zhiruili>Github</a></li>
<li><a href=/index.xml>RSS</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/archive>Archive</a></li>
<li><a href=https://www.github.com/zhiruili>Github</a></li>
<li><a href=/index.xml>RSS</a></li>
</ul>
</nav>
<span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span>
<span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg>
</span>
</span>
</span>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>使用 Future 进行并发编程</h1>
<div class=post-meta>
<span class=post-date>
2016-08-27
</span>
</div>
<span class=post-tags>
<a href=/tags/concurrency/>#Concurrency</a>&nbsp;
<a href=/tags/java/>#Java</a>&nbsp;
<a href=/tags/scala/>#Scala</a>&nbsp;
</span>
<div class=post-content>
<h2 id=future-的概念>Future 的概念</h2>
<p>在编程的时候，常常会遇到需要并行处理一些代码，最原始的做法就是创建不同的线程进行处理，但是线程之间的同步处理非常麻烦而且容易出错，如果要同时得到几个线程的结果并且通过这些结果进行进一步的计算，则需要共享变量或者进行线程间通信，无论如何都非常难以处理。另外，直接使用线程也使得代码灵活性不高，比如在双核机器上可能只希望使用两个线程执行代码，到了四核机器上就希望最多能有四个线程了。Future 能够提供一个高层的抽象，将计算任务的并发化和计算最终的执行方式分离，使得这类处理更为方便。Future 作为一个代理对象代表一个可能完成也可能未完成的值 <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，通过对 future 进行操作，能够获取内部的计算是否已经完成，是否出现异常，计算结果是什么等信息。</p>
<h2 id=java-中的-future>Java 中的 <code>Future</code></h2>
<p>Java 很早就提供了 <code>Future</code> 接口 <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，使用起来大概是这样的：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ArchiveSearcher</span> <span style=color:#f92672>{</span> String <span style=color:#a6e22e>search</span><span style=color:#f92672>(</span>String target<span style=color:#f92672>);</span> <span style=color:#f92672>}</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>App</span> <span style=color:#f92672>{</span>
  ExecutorService executor <span style=color:#f92672>=</span> <span style=color:#f92672>...</span> <span style=color:#f92672>;</span>  <span style=color:#75715e>// init executor service
</span><span style=color:#75715e></span>  ArchiveSearcher searcher <span style=color:#f92672>=</span> <span style=color:#f92672>...</span> <span style=color:#f92672>;</span>  <span style=color:#75715e>// init searcher
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>showSearch</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> String target<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
    Future<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> future <span style=color:#f92672>=</span> executor<span style=color:#f92672>.</span><span style=color:#a6e22e>submit</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Callable<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;()</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>call</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>return</span> searcher<span style=color:#f92672>.</span><span style=color:#a6e22e>search</span><span style=color:#f92672>(</span>target<span style=color:#f92672>);</span>
        <span style=color:#f92672>}</span>
    <span style=color:#f92672>});</span>
    displayOtherThings<span style=color:#f92672>();</span>  <span style=color:#75715e>// do other things while searching
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
      displayText<span style=color:#f92672>(</span>future<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>());</span>  <span style=color:#75715e>// use future
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ExecutionException ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> 
      cleanup<span style=color:#f92672>();</span> 
      <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span> 
    <span style=color:#f92672>}</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>这段代码是一个搜索与展示搜索结果的代码，<code>showSearch</code> 方法接收待搜索字符串，并调用 <code>executor</code> 的 <code>submit</code> 方法来提交一个搜索任务。<code>executor</code> 的类型是 <code>ExecutorService</code>，用于将任务的提交和任务执行的具体实现机制解绑 <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>，一般用线程池实现 <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>。当提交的任务是具有返回值的时候，<code>submit</code> 返回的不是这个任务完成后的值（例如这里需要返回的搜索结果是 <code>String</code> 类型），因为此时这个任务尚未执行完成。为了能在之后获取到这个值，此时需要返回一个占位对象，或者说是一个对结果值的代理对象，这个对象就是一个 future。这个 future 是立刻返回的，不会阻塞当前线程，这样，future 内的任务就能和 future 外的任务并发地进行计算，例如此处调用 <code>displayOtherThings</code> 来显示其他内容。当 <code>displayOtherThings</code> 执行完成，就去执行 <code>displayText</code> 来显示搜索结果，搜索结果的获取需要调用 <code>Future</code> 的 <code>get</code> 方法，此处 <code>future</code> 的类型是 <code>Future&lt;String></code>，其 <code>get</code> 方法的返回值类型就为 <code>String</code>。注意如果 future 的结果尚未计算出来，那么 <code>Future</code> 的 <code>get</code> 方法将阻塞当前线程。</p>
<p>在 Java 8 里提供了 Lambda 表达式，上面的例子可以简化为：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>App</span> <span style=color:#f92672>{</span>
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>showSearch</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> String target<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
    Future<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> future <span style=color:#f92672>=</span> executor<span style=color:#f92672>.</span><span style=color:#a6e22e>submit</span><span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> searcher<span style=color:#f92672>.</span><span style=color:#a6e22e>search</span><span style=color:#f92672>(</span>target<span style=color:#f92672>));</span>
    displayOtherThings<span style=color:#f92672>();</span>  <span style=color:#75715e>// do other things while searching
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
      displayText<span style=color:#f92672>(</span>future<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>());</span>  <span style=color:#75715e>// use future
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ExecutionException ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> 
      <span style=color:#75715e>// ...
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>Java 提供了一些对 future 的监控和操作手段：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Future</span><span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>cancel</span><span style=color:#f92672>(</span><span style=color:#66d9ef>boolean</span> mayInterruptIfRunning<span style=color:#f92672>);</span>
  V <span style=color:#a6e22e>get</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> InterruptedException<span style=color:#f92672>,</span> ExecutionException<span style=color:#f92672>;</span>
  V <span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> timeout<span style=color:#f92672>,</span> TimeUnit unit<span style=color:#f92672>)</span>
    <span style=color:#66d9ef>throws</span> InterruptedException<span style=color:#f92672>,</span> ExecutionException<span style=color:#f92672>,</span> TimeoutException<span style=color:#f92672>;</span>
  <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isCancelled</span><span style=color:#f92672>();</span>
  <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isDone</span><span style=color:#f92672>();</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>从 API 可以看出，<code>Future</code> 里的值是只能获取不能设置的，因为 future 从概念上来说就是对某一值的一个只读的占位符，这个值可能暂时没有计算出来，也可能永远无法计算出来。对于这个值在计算过程中出现异常而无法获取的情况，在 Java 中使用 <code>get</code> 方法抛出的异常来表示，<code>get</code> 方法会抛出如下 3 个异常：</p>
<blockquote>
<p><code>CancellationException</code> - if the computation was cancelled
<code>InterruptedException</code> - if the current thread was interrupted while waiting
<code>ExecutionException</code> - if the computation threw an exception</p>
</blockquote>
<p>但是，这套 <code>Future</code> 的 API 存在一些问题，首先，要获取一个 future 的计算结果必须要同步获取，这就对灵活性产生了很多限制，另外，这套 API 没有提供 future 间的组合方式，复杂的组合变得困难。考虑如下情况：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>SearcherServiceFetcher</span> <span style=color:#f92672>{</span> String <span style=color:#a6e22e>fetch</span><span style=color:#f92672>(</span>String type<span style=color:#f92672>);</span> <span style=color:#f92672>}</span>
<span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ArchiveSearcher</span> <span style=color:#f92672>{</span> 
  String <span style=color:#a6e22e>search</span><span style=color:#f92672>(</span>String service<span style=color:#f92672>,</span> String config<span style=color:#f92672>,</span> String target<span style=color:#f92672>);</span> 
<span style=color:#f92672>}</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>App</span> <span style=color:#f92672>{</span>
  ExecutorService executor <span style=color:#f92672>=</span> <span style=color:#f92672>...</span> <span style=color:#f92672>;</span>  <span style=color:#75715e>// init executor service
</span><span style=color:#75715e></span>  SearcherServiceFetcher serviceFetcher <span style=color:#f92672>=</span> <span style=color:#f92672>...</span> <span style=color:#f92672>;</span>  <span style=color:#75715e>// init searcher service fetcher
</span><span style=color:#75715e></span>  ArchiveSearcher searcher <span style=color:#f92672>=</span> <span style=color:#f92672>...</span> <span style=color:#f92672>;</span>  <span style=color:#75715e>// init searcher
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>showSearch</span><span style=color:#f92672>(</span><span style=color:#66d9ef>final</span> String type<span style=color:#f92672>,</span> <span style=color:#66d9ef>final</span> String target<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
    Future<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> resultFuture  <span style=color:#f92672>=</span> executor<span style=color:#f92672>.</span><span style=color:#a6e22e>submit</span><span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>
      Future<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> serviceFuture <span style=color:#f92672>=</span>  <span style=color:#75715e>// future for fetching searcher service
</span><span style=color:#75715e></span>        executor<span style=color:#f92672>.</span><span style=color:#a6e22e>submit</span><span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> serviceFetcher<span style=color:#f92672>.</span><span style=color:#a6e22e>fetch</span><span style=color:#f92672>(</span>type<span style=color:#f92672>));</span>
      Future<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> configFuture <span style=color:#f92672>=</span>   <span style=color:#75715e>// future for reading config
</span><span style=color:#75715e></span>        executor<span style=color:#f92672>.</span><span style=color:#a6e22e>submit</span><span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> readConfig<span style=color:#f92672>());</span>
      <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>  <span style=color:#75715e>// handle failure of fetching service
</span><span style=color:#75715e></span>        String service <span style=color:#f92672>=</span> serviceFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>();</span>  <span style=color:#75715e>// get service
</span><span style=color:#75715e></span>        String config <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>;</span>
        <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>  <span style=color:#75715e>// nested try-catch block, for reading config
</span><span style=color:#75715e></span>          config <span style=color:#f92672>=</span> configFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>();</span>  <span style=color:#75715e>// get config
</span><span style=color:#75715e></span>        <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ExecutionException ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
          config <span style=color:#f92672>=</span> getDefaultConfig<span style=color:#f92672>();</span>  <span style=color:#75715e>// if fail to read config, use default
</span><span style=color:#75715e></span>        <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>return</span> searcher<span style=color:#f92672>.</span><span style=color:#a6e22e>search</span><span style=color:#f92672>(</span>service<span style=color:#f92672>,</span> config<span style=color:#f92672>,</span> target<span style=color:#f92672>);</span>  <span style=color:#75715e>// search
</span><span style=color:#75715e></span>      <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ExecutionException ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>throw</span> ex<span style=color:#f92672>.</span><span style=color:#a6e22e>getCause</span><span style=color:#f92672>();</span>  <span style=color:#75715e>// if fail to fetch service, throw exception
</span><span style=color:#75715e></span>      <span style=color:#f92672>}</span>
    <span style=color:#f92672>});</span>
    displayOtherThings<span style=color:#f92672>();</span>  <span style=color:#75715e>// do other things while searching
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
      String textForDisplay <span style=color:#f92672>=</span> render<span style=color:#f92672>(</span>resultFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>get</span><span style=color:#f92672>());</span>  <span style=color:#75715e>// render result
</span><span style=color:#75715e></span>      displayText<span style=color:#f92672>(</span>textForDisplay<span style=color:#f92672>);</span>  <span style=color:#75715e>// display result
</span><span style=color:#75715e></span>    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span> <span style=color:#f92672>(</span>ExecutionException ex<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> 
      cleanup<span style=color:#f92672>();</span> 
      <span style=color:#66d9ef>return</span><span style=color:#f92672>;</span> 
    <span style=color:#f92672>}</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>在这个例子里，搜索不但依赖于传入的搜索内容，还要依赖于根据搜索类型决定的搜索服务提供者以及搜索配置，由于获取搜索服务提供者和读取配置的过程都是需要费时的，所以此处将这两个任务都提交给 <code>executor</code> 处理，获得两个 future 后，我们首先查看搜索服务提供者是否成功被获取到了，如果获取失败，就直接抛出一个异常。如果服务提供者获取成功了，就去查看配置是否读取成功，由于读取配置的过程也可能出错，所以这里还要进行错误处理，如果配置读取不到，就使用默认的配置。获取到服务提供者和配置后再进行搜索并返回结果。在 <code>displayOtherThings</code> 结束后，调用 <code>resultFuture</code> 的 <code>get</code> 方法获取搜索结果，然后渲染获得的内容，再进行展示。这段代码虽然不长，但也足够难读了，从这段代码可以发现，由于每一次的 <code>get</code> 操作都可能抛出异常，我们需要进行很多异常处理，再加上嵌套的 future，使得主要的代码逻辑非常混乱，不但难以阅读，且调试相当困难，最后的阻塞调用也可能会对性能造成很大影响。</p>
<h2 id=对-java-future-api-的改进>对 Java <code>Future</code> API 的改进</h2>
<p>要改善 Java 的 <code>Future</code> API，首先要提供接口让用户从阻塞调用变为非阻塞调用，也就是使用回调函数（使用 Scala 表示）：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> onComplete<span style=color:#f92672>(</span>callback<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>T</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Unit</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span>
  <span style=color:#66d9ef>def</span> cancel<span style=color:#f92672>(</span>mayInterruptIfRunning<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span>
  <span style=color:#66d9ef>def</span> isCancelled<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span>
  <span style=color:#66d9ef>def</span> isDone<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Boolean</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>使用的时候大概是这样：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala>future<span style=color:#f92672>.</span>onComplete<span style=color:#f92672>(</span>res <span style=color:#66d9ef>=&gt;</span> consume<span style=color:#f92672>(</span>res<span style=color:#f92672>))</span>
</code></pre></div><p>使用回调函数之后，在 <code>onComplete</code> 处就不会阻塞线程，当 future 所代理的值被计算出来后，通过 <code>onComplete</code> 注册的回调函数就会被调用，从而执行所需的代码。但很快可以发现，由于整个过程是异步的，所以这样无法直接使用 try-catch 块来捕获异常，如前所述，Java 的 <code>Future</code> 的 <code>get</code> 方法的完整声明其实是这样的：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>V <span style=color:#a6e22e>get</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> InterruptedException<span style=color:#f92672>,</span> ExecutionException<span style=color:#f92672>;</span>
V <span style=color:#a6e22e>get</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span> timeout<span style=color:#f92672>,</span> TimeUnit unit<span style=color:#f92672>)</span>
    <span style=color:#66d9ef>throws</span> InterruptedException<span style=color:#f92672>,</span> ExecutionException<span style=color:#f92672>,</span> TimeoutException<span style=color:#f92672>;</span>
</code></pre></div><p>所以，<code>get</code> 的声明其实不是 <code>() => T</code> 而是 <code>() => Try[T]</code>，对应 <code>get</code> 改为异步后的 <code>onComplete</code> 不应该是 <code>T => Unit</code>，而应该是 <code>Try[T] => Unit</code>。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> onComplete<span style=color:#f92672>(</span>callback<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Try</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#a6e22e>Unit</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span>
  <span style=color:#66d9ef>def</span> onSuccess<span style=color:#f92672>(</span>callback<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>T</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Unit</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span>
  <span style=color:#66d9ef>def</span> onFailure<span style=color:#f92672>(</span>callback<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Throwable</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Unit</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span>
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><p>例如前面的例子，用异步回调的方式写出来大概是这样的：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>SearcherServiceFetcher</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>def</span> fetch<span style=color:#f92672>(</span>type<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>}</span>
<span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>ArchiveSearcher</span> <span style=color:#f92672>{</span> 
  <span style=color:#66d9ef>def</span> search<span style=color:#f92672>(</span>service<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>,</span> config<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>,</span> target<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span> 
<span style=color:#f92672>}</span>
<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>App</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>val</span> executor<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ExecutorService</span> <span style=color:#f92672>=</span> <span style=color:#f92672>...</span>
  <span style=color:#66d9ef>val</span> serviceFetcher<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>SearcherServiceFetcher</span> <span style=color:#f92672>=</span> <span style=color:#f92672>...</span>
  <span style=color:#66d9ef>val</span> searcher<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ArchiveSearcher</span> <span style=color:#f92672>=</span> <span style=color:#f92672>...</span>
  <span style=color:#66d9ef>def</span> showSearch<span style=color:#f92672>(</span>type<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>,</span> target<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>val</span> resultFuture<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>String</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> executor<span style=color:#f92672>.</span>submit <span style=color:#f92672>{</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> 
      <span style=color:#66d9ef>val</span> serviceFuture<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>String</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> 
        executor<span style=color:#f92672>.</span>submit <span style=color:#f92672>{</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> serviceFetcher<span style=color:#f92672>.</span>fetch<span style=color:#f92672>(</span>type<span style=color:#f92672>)</span> <span style=color:#f92672>}</span>
      <span style=color:#66d9ef>val</span> configFuture<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>String</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> 
        executor<span style=color:#f92672>.</span>submit <span style=color:#f92672>{</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> readConfig<span style=color:#f92672>()</span> <span style=color:#f92672>}</span>
      serviceFuture<span style=color:#f92672>.</span>onComplete <span style=color:#f92672>{</span>  <span style=color:#75715e>// callback for fetching service
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Success</span><span style=color:#f92672>(</span>service<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span>
          configFuture<span style=color:#f92672>.</span>onComplete <span style=color:#f92672>{</span>  <span style=color:#75715e>// nested callback for reading config
</span><span style=color:#75715e></span>            <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Success</span><span style=color:#f92672>(</span>config<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> 
              searcher<span style=color:#f92672>.</span>search<span style=color:#f92672>(</span>service<span style=color:#f92672>,</span> config<span style=color:#f92672>,</span> target<span style=color:#f92672>)</span>
            <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Failure</span><span style=color:#f92672>(</span>thw<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span>  <span style=color:#75715e>// if fail to read config, use default
</span><span style=color:#75715e></span>              searcher<span style=color:#f92672>.</span>search<span style=color:#f92672>(</span>service<span style=color:#f92672>,</span> getDefaultConfig<span style=color:#f92672>(),</span> target<span style=color:#f92672>)</span>
          <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Failure</span><span style=color:#f92672>(</span>thw<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#66d9ef>throw</span> thw  <span style=color:#75715e>// if fail to get service, throw exception
</span><span style=color:#75715e></span>      <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
    resultFuture<span style=color:#f92672>.</span>onComplete <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Success</span><span style=color:#f92672>(</span>result<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> 
        <span style=color:#66d9ef>val</span> textForDisplay<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>=</span> render<span style=color:#f92672>(</span>result<span style=color:#f92672>)</span>
        displayText<span style=color:#f92672>(</span>textForDisplay<span style=color:#f92672>)</span>
      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Failure</span><span style=color:#f92672>(</span>thw<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> cleanup<span style=color:#f92672>()</span>
    <span style=color:#f92672>}</span>
    displayOtherThings<span style=color:#f92672>()</span>  <span style=color:#75715e>// do other things while searching
</span><span style=color:#75715e></span>  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>上面的代码为了和 Java 版本的进行对照，所以使用了类似的调用，但由于是使用 Scala，上述的代码的类型签名会不太一样（例如 Scala 使用 <code>ExecutionContext</code> 而非 <code>ExecutorService</code>，但作用是类似的），另外可以更加简练，例如用隐式的参数传递 <code>executor</code>，使用类型推导减少类型声明等，实际写出来大概是这样的：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>App</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>val</span> context <span style=color:#66d9ef>=</span> <span style=color:#f92672>...</span>  <span style=color:#75715e>// init execution context 
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>val</span> serviceFetcher <span style=color:#66d9ef>=</span> <span style=color:#f92672>...</span>
  <span style=color:#66d9ef>val</span> searcher <span style=color:#66d9ef>=</span> <span style=color:#f92672>...</span>
  <span style=color:#66d9ef>def</span> showSearch<span style=color:#f92672>(</span>type<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>,</span> target<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>val</span> resultFuture <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Future</span> <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>val</span> serviceFuture <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Future</span> <span style=color:#f92672>{</span> serviceFetcher<span style=color:#f92672>.</span>fetch<span style=color:#f92672>(</span>type<span style=color:#f92672>)</span> <span style=color:#f92672>}</span>
      <span style=color:#66d9ef>val</span> configFuture <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Future</span> <span style=color:#f92672>{</span> readConfig<span style=color:#f92672>()</span> <span style=color:#f92672>}</span>
      serviceFuture<span style=color:#f92672>.</span>onComplete <span style=color:#f92672>{</span>
        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Success</span><span style=color:#f92672>(</span>service<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span>
          configFuture<span style=color:#f92672>.</span>onComplete <span style=color:#f92672>{</span>
            <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Success</span><span style=color:#f92672>(</span>config<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> 
              searcher<span style=color:#f92672>.</span>search<span style=color:#f92672>(</span>service<span style=color:#f92672>,</span> config<span style=color:#f92672>,</span> target<span style=color:#f92672>)</span>
            <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Failure</span><span style=color:#f92672>(</span>thw<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> 
              searcher<span style=color:#f92672>.</span>search<span style=color:#f92672>(</span>service<span style=color:#f92672>,</span> getDefaultConfig<span style=color:#f92672>(),</span> target<span style=color:#f92672>)</span>
          <span style=color:#f92672>}</span>
        <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Failure</span><span style=color:#f92672>(</span>thw<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#66d9ef>throw</span> thw
      <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
    resultFuture<span style=color:#f92672>.</span>onComplete <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Success</span><span style=color:#f92672>(</span>result<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> 
        <span style=color:#66d9ef>val</span> textForDisplay <span style=color:#66d9ef>=</span> render<span style=color:#f92672>(</span>result<span style=color:#f92672>)</span>
        displayText<span style=color:#f92672>(</span>textForDisplay<span style=color:#f92672>)</span>
      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Failure</span><span style=color:#f92672>(</span>thw<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> cleanup<span style=color:#f92672>()</span>
    <span style=color:#f92672>}</span>
    displayOtherThings<span style=color:#f92672>()</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>这个使用回调函数而非阻塞获取结果的版本的改进之处在于它使得主线程不会因为这些计算而阻塞，但是从代码逻辑上看，即便是依靠语法的简洁减少了一些代码的书写，整段代码还是比较难读。显然，使用回调函数实现的这个版本也是难以组合的，操作起来甚至比直接使用阻塞的 <code>get</code> 调用还要复杂，很容易就陷入 JavaScript 程序常常遇到的「Callback Hell」<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>。由于 <code>onComplete</code> 返回的是 <code>Unit</code>，所以整个回调过程完全是通过副作用的形式产生效果的。嵌套的回调代码比顺序执行的 <code>get</code> 调用更为混乱。所以现在的实现目标是：尽管最后的回调完全是副作用过程，但在进行 future 间组合时不让用户去关心这些副作用，也就是希望能将计算中的组合和最终的计算实现分离。</p>
<p>首先，一个常用的组合子就是 <code>map</code> 了（真实 API 会有隐式传递的 <code>ExecutionContext</code> 参数，这里省去，不影响表意）：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> map<span style=color:#f92672>[</span><span style=color:#66d9ef>R</span><span style=color:#f92672>](</span>f<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>T</span> <span style=color:#f92672>=&gt;</span> R<span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>R</span><span style=color:#f92672>]</span>
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><p><code>map</code> 方法产生一个新的 future，如果原 future 成功计算出了结果，那么新的 future 的结果就是将 <code>f</code> 作用于原 future 所代理的值上所得出的结果，如果原 future 出现了异常导致失败，或者 <code>f</code> 的调用过程出现异常，那么新的 future 将会失败。</p>
<p>比如，上面的代码中获得结果后需要对结果进行渲染，然后再显示，使用 <code>map</code> 就可以写成：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala>resultFuture<span style=color:#f92672>.</span>map<span style=color:#f92672>(</span>render<span style=color:#f92672>).</span>onComplete <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Success</span><span style=color:#f92672>(</span>textForDisplay<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> 
    displayText<span style=color:#f92672>(</span>textForDisplay<span style=color:#f92672>)</span>
  <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Failure</span><span style=color:#f92672>(</span>thw<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> cleanup<span style=color:#f92672>()</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>但为了能处理某一 future 的构建依赖于前一个 future 的结果的情况（例如 config 和 service 的获取），光有 <code>map</code> 这个组合子还不够，我们还需要有一个组合子能够去处理上下文相关的情景，这个组合子就是 <code>flatMap</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> flatMap<span style=color:#f92672>[</span><span style=color:#66d9ef>R</span><span style=color:#f92672>](</span>f<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>T</span> <span style=color:#f92672>=&gt;</span> <span style=color:#a6e22e>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>R</span><span style=color:#f92672>])</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>R</span><span style=color:#f92672>]</span>
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><p><code>flatMap</code> 方法会根据原 future 的计算结果来产生一个新的 future，如果原 future 成功计算出了结果，那么新的 future 就是将 <code>f</code> 作用于原 future 所代理的值上所得出的 future，如果原 future 出现了异常导致失败，或者 <code>f</code> 的调用过程出现异常，又或者新的 future 自身出现了异常，那么新的 future 将会失败。有了这个组合子，配合 Scala 的 for-comprehension，就可以这样写：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>val</span> resultFuture <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>for</span> <span style=color:#f92672>{</span>
  service <span style=color:#66d9ef>&lt;-</span> <span style=color:#a6e22e>Future</span> <span style=color:#f92672>{</span> serviceFetcher<span style=color:#f92672>.</span>fetch<span style=color:#f92672>(</span>type<span style=color:#f92672>)</span> <span style=color:#f92672>}</span>
  config <span style=color:#66d9ef>&lt;-</span> <span style=color:#a6e22e>Future</span> <span style=color:#f92672>{</span> readConfig<span style=color:#f92672>()</span> <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span> <span style=color:#66d9ef>yield</span> searcher<span style=color:#f92672>.</span>search<span style=color:#f92672>(</span>service<span style=color:#f92672>,</span> config<span style=color:#f92672>,</span> target<span style=color:#f92672>)</span>

resultFuture<span style=color:#f92672>.</span>map<span style=color:#f92672>(</span>render<span style=color:#f92672>).</span>onComplete <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Success</span><span style=color:#f92672>(</span>textForDisplay<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> 
    displayText<span style=color:#f92672>(</span>textForDisplay<span style=color:#f92672>)</span>
  <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Failure</span><span style=color:#f92672>(</span>thw<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> cleanup<span style=color:#f92672>()</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>这段代码将被翻译为对 <code>flatMap</code> 和 <code>map</code> 的调用，但即便不懂 Scala 的语法，上面这段代码的目的也非常清晰，先取得搜索服务提供者，并命名为 <code>service</code>，取得配置，并命名为 <code>config</code>，然后通过这两个信息进行搜索。之后将搜索结果进行渲染，再注册回调函数，在整个过程完成后进行展示。</p>
<p>上面的代码没有进行错误处理，除了 <code>map</code> 和 <code>flatMap</code> 之外，Scala 的 <code>Future</code> 还提供了更多的组合子，例如用于从异常中恢复的 <code>recover</code>，用于筛选结果的 <code>filter</code>，用于进行副作用处理的 <code>foreach</code> 等 <sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> <sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup>。配合之下，前面的代码将变成这样：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>App</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>val</span> context <span style=color:#66d9ef>=</span> <span style=color:#f92672>...</span>
  <span style=color:#66d9ef>val</span> serviceFetcher <span style=color:#66d9ef>=</span> <span style=color:#f92672>...</span>
  <span style=color:#66d9ef>val</span> searcher <span style=color:#66d9ef>=</span> <span style=color:#f92672>...</span>
  
  <span style=color:#66d9ef>def</span> showSearch<span style=color:#f92672>(</span>type<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>,</span> target<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span> 
    
    <span style=color:#66d9ef>val</span> displayTextFuture <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>for</span> <span style=color:#f92672>{</span>
      service <span style=color:#66d9ef>&lt;-</span> <span style=color:#a6e22e>Future</span> <span style=color:#f92672>{</span> serviceFetcher<span style=color:#f92672>.</span>fetch<span style=color:#f92672>(</span>type<span style=color:#f92672>)</span> <span style=color:#f92672>}</span>
      config <span style=color:#66d9ef>&lt;-</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Future</span> <span style=color:#f92672>{</span> readConfig<span style=color:#f92672>()</span> <span style=color:#f92672>}).</span>recover<span style=color:#f92672>(</span><span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> getDefaultConfig<span style=color:#f92672>)</span>
      result <span style=color:#66d9ef>&lt;-</span> <span style=color:#a6e22e>Future</span> <span style=color:#f92672>{</span> searcher<span style=color:#f92672>.</span>search<span style=color:#f92672>(</span>service<span style=color:#f92672>,</span> config<span style=color:#f92672>,</span> target<span style=color:#f92672>)</span> <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>yield</span> render<span style=color:#f92672>(</span>result<span style=color:#f92672>)</span>
    
    displayTextFuture<span style=color:#f92672>.</span>onComplete <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Success</span><span style=color:#f92672>(</span>textForDisplay<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> displayText<span style=color:#f92672>(</span>textForDisplay<span style=color:#f92672>)</span>
      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>Failure</span><span style=color:#f92672>(</span>thw<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> cleanup<span style=color:#f92672>()</span>
    <span style=color:#f92672>}</span>
    
    displayOtherThings<span style=color:#f92672>()</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>相比起之前的版本，这一版本可以说是惊人的简洁，虽然最后的回调是有副作用的，但是前面的组合根本不需要考虑这些副作用，可以将不同的 future 进行纯的组合，只有在最后才会碰到一次副作用的回调函数注册，而且展现出来的代码非常扁平，没有难读的嵌套。</p>
<p>虽然 Scala 的这一套 API 很优雅，但是受限于 Java 的语法，这个设计在 Java 上却无法直接照搬，例如上面那段代码中的 for-comprehension 部分将被翻译成：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>val</span> displayTextFuture <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Future</span> <span style=color:#f92672>{</span> serviceFetcher<span style=color:#f92672>.</span>fetch<span style=color:#f92672>(</span>type<span style=color:#f92672>)</span> <span style=color:#f92672>}</span> flatMap <span style=color:#f92672>{</span> 
  service <span style=color:#66d9ef>=&gt;</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Future</span> <span style=color:#f92672>{</span> readConfig<span style=color:#f92672>()</span> <span style=color:#f92672>}).</span>recover<span style=color:#f92672>(</span><span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> getDefaultConfig<span style=color:#f92672>)</span> flatMap <span style=color:#f92672>{</span>
    config <span style=color:#66d9ef>=&gt;</span> <span style=color:#a6e22e>Future</span> <span style=color:#f92672>{</span> searcher<span style=color:#f92672>.</span>search<span style=color:#f92672>(</span>service<span style=color:#f92672>,</span> config<span style=color:#f92672>,</span> target<span style=color:#f92672>)</span> <span style=color:#f92672>}</span> map <span style=color:#f92672>{</span>
      result <span style=color:#66d9ef>=&gt;</span> render<span style=color:#f92672>(</span>result<span style=color:#f92672>)</span>
    <span style=color:#f92672>}</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>由于 Java 没有类似 for-comprehension 的语法，如果直接照搬 Scala 的 API 设计，那就必须在 Java 的代码中写这样的嵌套处理了。这样的嵌套处理非常难读难写，所以，Java 8 设计了另外一套 API，实现在 <code>CompletableFuture</code> 中 <sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup>，举例而言：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CompletableFuture</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> Object 
  <span style=color:#66d9ef>implements</span> Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;,</span> CompletionStage<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
  
  <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> CompletableFuture<span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>thenApplyAsync</span>
    <span style=color:#f92672>(</span>Function<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>,</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>extends</span> U<span style=color:#f92672>&gt;</span> fn<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
      
  <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>U<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;</span> CompletableFuture<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>thenCombineAsync</span>
    <span style=color:#f92672>(</span>CompletionStage<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>extends</span> U<span style=color:#f92672>&gt;</span> other<span style=color:#f92672>,</span> 
     BiFunction<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>,</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>super</span> U<span style=color:#f92672>,</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>extends</span> V<span style=color:#f92672>&gt;</span> fn<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
       
  <span style=color:#66d9ef>public</span> CompletableFuture<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>thenAcceptAsync</span>
    <span style=color:#f92672>(</span>Consumer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>&gt;</span> action<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
  
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> CompletableFuture<span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>supplyAsync</span>
    <span style=color:#f92672>(</span>Supplier<span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> supplier<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
    
  <span style=color:#66d9ef>public</span> CompletableFuture<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>whenCompleteAsync</span>
    <span style=color:#f92672>(</span>BiConsumer<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>,</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>super</span> Throwable<span style=color:#f92672>&gt;</span> action<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
    
  <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> CompletableFuture<span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> <span style=color:#a6e22e>handleAsync</span>
    <span style=color:#f92672>(</span>BiFunction<span style=color:#f92672>&lt;?</span> <span style=color:#66d9ef>super</span> T<span style=color:#f92672>,</span> Throwable<span style=color:#f92672>,</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>extends</span> U<span style=color:#f92672>&gt;</span> fn<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
    
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><p>正如之前的在 <a href=/articles/covariant-and-contravariant>协变、逆变与不变</a> 一文中提到的一样，Java 的型变是在使用的地方进行限制的，所以这里的几个方法签名都非常难看，但对于使用者来说，其实并不太需要理会复杂的声明，将上面的声明看作这样就可以了：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>CompletableFuture</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> Object 
  <span style=color:#66d9ef>implements</span> Future<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;,</span> CompletionStage<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
  
  <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> CompletableFuture<span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> 
  <span style=color:#a6e22e>thenApplyAsync</span><span style=color:#f92672>((</span>T <span style=color:#f92672>-&gt;</span> U<span style=color:#f92672>)</span> fn<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
      
  <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>U<span style=color:#f92672>,</span>V<span style=color:#f92672>&gt;</span> CompletableFuture<span style=color:#f92672>&lt;</span>V<span style=color:#f92672>&gt;</span> 
  <span style=color:#a6e22e>thenCombineAsync</span><span style=color:#f92672>(</span>CompletableFuture<span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> other<span style=color:#f92672>,</span> <span style=color:#f92672>((</span>T<span style=color:#f92672>,</span> U<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> V<span style=color:#f92672>)</span> fn<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
       
  <span style=color:#66d9ef>public</span> CompletableFuture<span style=color:#f92672>&lt;</span>Void<span style=color:#f92672>&gt;</span> 
  <span style=color:#a6e22e>thenAcceptAsync</span><span style=color:#f92672>((</span>T <span style=color:#f92672>-&gt;</span> Void<span style=color:#f92672>)</span> action<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
  
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> CompletableFuture<span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> 
  <span style=color:#a6e22e>supplyAsync</span><span style=color:#f92672>((()</span> <span style=color:#f92672>-&gt;</span> U<span style=color:#f92672>)</span> supplier<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
    
  <span style=color:#66d9ef>public</span> CompletableFuture<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> 
  <span style=color:#a6e22e>whenCompleteAsync</span><span style=color:#f92672>(((</span>T<span style=color:#f92672>,</span> Throwable<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> Void<span style=color:#f92672>)</span> action<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
    
  <span style=color:#66d9ef>public</span> <span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> CompletableFuture<span style=color:#f92672>&lt;</span>U<span style=color:#f92672>&gt;</span> 
  <span style=color:#a6e22e>handleAsync</span><span style=color:#f92672>(((</span>T<span style=color:#f92672>,</span> Throwable<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> U<span style=color:#f92672>)</span> fn<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
    
  <span style=color:#75715e>// ...
</span><span style=color:#75715e></span><span style=color:#f92672>}</span>
</code></pre></div><p>这一套 API 其实光看方法签名就能大概猜到它们的作用了，例如 <code>thenApply</code> 和 <code>thenApplyAsync</code> 就相当于 <code>map</code>，<code>whenComplete</code> 和 <code>whenCompleteAsync</code> 就相当于 <code>onComplete</code> 等。在配合 Java 8 的 Lambda 表达式之后，使用时写出的代码也是相当清晰的，例如之前的代码可以写成：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>CompletableFuture<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> serviceFuture <span style=color:#f92672>=</span>  <span style=color:#75715e>// fetch searcher service
</span><span style=color:#75715e></span>  CompletableFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>supplyAsync</span><span style=color:#f92672>(</span>  <span style=color:#75715e>// use supplyAsync to construct future
</span><span style=color:#75715e></span>    <span style=color:#f92672>()</span> <span style=color:#f92672>-&gt;</span> serviceFetcher<span style=color:#f92672>.</span><span style=color:#a6e22e>fetch</span><span style=color:#f92672>(</span>type<span style=color:#f92672>));</span>  
  
CompletableFuture<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> configFuture <span style=color:#f92672>=</span>  <span style=color:#75715e>// read config
</span><span style=color:#75715e></span>  CompletableFuture
    <span style=color:#f92672>.</span><span style=color:#a6e22e>supplyAsync</span><span style=color:#f92672>(()</span> <span style=color:#f92672>-&gt;</span> readConfig<span style=color:#f92672>())</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>handleAsync</span><span style=color:#f92672>((</span>config<span style=color:#f92672>,</span> ex<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span>  <span style=color:#75715e>// use handleAsync to handle result
</span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ex <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>return</span> config<span style=color:#f92672>;</span>
      <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>return</span> getDefaultConfig<span style=color:#f92672>();</span>  <span style=color:#75715e>// if fail to read config, use default
</span><span style=color:#75715e></span>    <span style=color:#f92672>});</span>
    
CompletableFuture<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> textForDisplayFuture <span style=color:#f92672>=</span>  <span style=color:#75715e>// search and render
</span><span style=color:#75715e></span>  serviceFuture
    <span style=color:#f92672>.</span><span style=color:#a6e22e>thenCombineAsync</span><span style=color:#f92672>(</span>  <span style=color:#75715e>// use thenCombineAsync to combine result
</span><span style=color:#75715e></span>      configFuture<span style=color:#f92672>,</span> 
      <span style=color:#f92672>(</span>service<span style=color:#f92672>,</span> config<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> searcher<span style=color:#f92672>.</span><span style=color:#a6e22e>search</span><span style=color:#f92672>(</span>service<span style=color:#f92672>,</span> config<span style=color:#f92672>,</span> target<span style=color:#f92672>))</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>thenApplyAsync</span><span style=color:#f92672>((</span>result<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> render<span style=color:#f92672>(</span>result<span style=color:#f92672>));</span>  <span style=color:#75715e>// render result
</span><span style=color:#75715e></span>      
textForDisplayFuture<span style=color:#f92672>.</span><span style=color:#a6e22e>whenCompleteAsync</span><span style=color:#f92672>((</span>text<span style=color:#f92672>,</span> ex<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>{</span> 
  <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ex <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> cleanup<span style=color:#f92672>();</span> <span style=color:#66d9ef>else</span> displayText<span style=color:#f92672>(</span>text<span style=color:#f92672>);</span> 
<span style=color:#f92672>});</span>
  
displayOtherThings<span style=color:#f92672>();</span>
</code></pre></div><p>注意到在这套 API 中，为了避免使用类似 <code>flatMap</code> 这样的函数导致嵌套调用，Java 使用 <code>thenCombine</code> 和 <code>thenCombineAsync</code> 来承担 Scala 中 <code>flatMap</code> 的作用，处理上下文相关的场景，但这个组合子并没有 <code>flatMap</code> 那么强大。为了说明这个问题，考虑一个计算依赖于三个 future 的计算结果的场景。假设现在需要用 a，b，c 三个字符串构建一个新的字符串，而这三个字符串分别由 <code>futureA</code>，<code>futureB</code>，<code>futureC</code> 代理，那么可能就要写出如下的代码：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Pair</span><span style=color:#f92672>&lt;</span>X<span style=color:#f92672>,</span> Y<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>public</span> X x<span style=color:#f92672>;</span>
  <span style=color:#66d9ef>public</span> Y y<span style=color:#f92672>;</span>
  <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Pair</span><span style=color:#f92672>(</span>X x<span style=color:#f92672>,</span> Y y<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>x</span> <span style=color:#f92672>=</span> x<span style=color:#f92672>;</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>.</span><span style=color:#a6e22e>y</span> <span style=color:#f92672>=</span> y<span style=color:#f92672>;</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
CompletableFuture<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> stringFuture <span style=color:#f92672>=</span>
  futureA
    <span style=color:#f92672>.</span><span style=color:#a6e22e>thenCombineAsync</span><span style=color:#f92672>(</span>futureB<span style=color:#f92672>,</span> <span style=color:#f92672>(</span>a<span style=color:#f92672>,</span> b<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> Pair<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>,</span> String<span style=color:#f92672>&gt;(</span>a<span style=color:#f92672>,</span> b<span style=color:#f92672>))</span>
    <span style=color:#f92672>.</span><span style=color:#a6e22e>thenCombineAsync</span><span style=color:#f92672>(</span>futureC<span style=color:#f92672>,</span> <span style=color:#f92672>(</span>pair<span style=color:#f92672>,</span> b<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> buildString<span style=color:#f92672>(</span>pair<span style=color:#f92672>.</span><span style=color:#a6e22e>x</span><span style=color:#f92672>,</span> pair<span style=color:#f92672>.</span><span style=color:#a6e22e>y</span><span style=color:#f92672>,</span> c<span style=color:#f92672>));</span>
</code></pre></div><p>而 Scala 只需要这样写：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>val</span> stringFuture <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>for</span> <span style=color:#f92672>{</span>
  a <span style=color:#66d9ef>&lt;-</span> futureA
  b <span style=color:#66d9ef>&lt;-</span> futureB
  c <span style=color:#66d9ef>&lt;-</span> futureC
<span style=color:#f92672>}</span> <span style=color:#66d9ef>yield</span> buildString<span style=color:#f92672>(</span>a<span style=color:#f92672>,</span> b<span style=color:#f92672>,</span> c<span style=color:#f92672>)</span>
</code></pre></div><p>显然，这个组合子只能方便地处理两个 future 的结合，没有 <code>flatMap</code> 强大，事实上，可以用 <code>flatMap</code> 来很容易地实现 <code>thenCombine</code>，一般称为 <code>map2</code>：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> map2<span style=color:#f92672>(</span>other<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>U</span><span style=color:#f92672>],</span> f<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>T</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>U</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> V<span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>V</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>for</span> <span style=color:#f92672>{</span>
    t <span style=color:#66d9ef>&lt;-</span> <span style=color:#66d9ef>this</span>
    u <span style=color:#66d9ef>&lt;-</span> other
  <span style=color:#f92672>}</span> <span style=color:#66d9ef>yield</span> f<span style=color:#f92672>(</span>t<span style=color:#f92672>,</span> u<span style=color:#f92672>)</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>虽然 Java 的这个实现没有 Scala 版本的代码优雅，但是在大多数情况下也够用，尤其是在受到 Java 的语法局限的情况下，这个已经是一个比较好的处理了。从获取搜索结果并显示的例子中可以看出，使用这套 API 的关键优点在于这个版本的代码也做到了在异步回调避免阻塞主线程的情况下，加强了 future 间的组合性，避免出现最初版本的难读代码。</p>
<p>总之，在 Java 8 之后，应该使用新的 API 来操作 future，以便能更加简便地处理并发和异步代码。另外，对于 API 设计而言，要尽可能加强组件与组件之间的可组合性，将无法组合的部分抽离，只有在最后才调用，以使得 API 更加易用。</p>
<h2 id=参考资料>参考资料</h2>
<section class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1 role=doc-endnote>
<p><a href=https://en.wikipedia.org/wiki/Futures_and_promises>Futures and promises - Wikipedia</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:2 role=doc-endnote>
<p><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html>Future - JavaSE 8 References</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:3 role=doc-endnote>
<p><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html>Executor - JavaSE 8 References</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:4 role=doc-endnote>
<p><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html>ExecutorService - JavaSE 8 References</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:5 role=doc-endnote>
<p><a href=http://callbackhell.com/>Callback Hell - A guide to writing asynchronous JavaScript programs</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:6 role=doc-endnote>
<p><a href=http://docs.scala-lang.org/overviews/core/futures.html>Futures and Promises - Scala Documentation</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:7 role=doc-endnote>
<p><a href=http://www.scala-lang.org/files/archive/nightly/docs/library/scala/concurrent/Future.html>Future - Scala API References</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
<li id=fn:8 role=doc-endnote>
<p><a href=https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html>CompletableFuture - JavaSE 8 References</a>&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p>
</li>
</ol>
</section>
</div>
<div class=pagination>
<div class=pagination__title>
<span class=pagination__title-h>Read other posts</span>
<hr>
</div>
<div class=pagination__buttons>
<span class="button previous">
<a href=/posts/parser-combinator/>
<span class=button__icon>←</span>
<span class=button__text>Parser Combinator</span>
</a>
</span>
<span class="button next">
<a href=/posts/java-puzzlers/>
<span class=button__text>Java Puzzlers</span>
<span class=button__icon>→</span>
</a>
</span>
</div>
</div>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//ZhiruiLi.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user"><p>本网站采用 <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a> 协议进行授权</p><p>© 2021 Zhirui Li. All rights reserved.</p></div>
</div>
</footer>
<script src=/assets/main.js></script>
<script src=/assets/prism.js></script><p>我的博客即将同步至腾讯云+社区，<a target=_blank href="https://cloud.tencent.com/developer/support-plan?invite_code=11dehb9vzutlx">邀请大家一同入驻</a>。</p>
</div>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-80302213-1','auto'),ga('send','pageview'))</script>
</body>
</html>