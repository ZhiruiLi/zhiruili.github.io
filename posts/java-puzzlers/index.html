<!doctype html><html lang=cn>
<head>
<title>
Java Puzzlers ::
简易现代魔法 — Zhirui Li's Blog
</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="The Joy of Sets public class ShortSet { public static void main(String args[]) { Set&amp;lt;Short&amp;gt; s = new HashSet&amp;lt;Short&amp;gt;(); for (short i = 0; i &amp;lt; 100; i++) { s.add(i); s.remove(i - 1); } } System.out.println(s.size()); } 可能会认为这段代码输出的结果是 1，但实际上这段代码输出的结果是 10">
<meta name=keywords content="编程,计算机图形学,游戏开发">
<meta name=robots content="noodp">
<link rel=canonical href=/posts/java-puzzlers/>
<link rel=stylesheet href=/assets/style.css>
<link rel=stylesheet href=/style.css>
<link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png>
<link rel="shortcut icon" href=/img/favicon.png>
<link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Java Puzzlers">
<meta name=twitter:description content="看 Google 的 Java Puzzlers 技术视频的笔记">
<meta property="og:title" content="Java Puzzlers">
<meta property="og:description" content="看 Google 的 Java Puzzlers 技术视频的笔记">
<meta property="og:type" content="article">
<meta property="og:url" content="/posts/java-puzzlers/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2016-08-07T00:00:00+00:00">
<meta property="article:modified_time" content="2016-08-07T00:00:00+00:00"><meta property="og:site_name" content="简易现代魔法">
<script>var posts=document.getElementById('posts-list');posts&&quicklink({el:posts,priority:!0})</script>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
</head>
<body>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ class=logo style=text-decoration:none>
<span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span>
<span class=logo__text>简易现代魔法</span>
<span class=logo__cursor></span>
</a>
<span class=header__right>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/>Home</a></li>
<li><a href=/posts>Posts</a></li>
<li><a href=https://www.github.com/zhiruili>Github</a></li>
<li><a href=/index.xml>RSS</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/>Home</a></li>
<li><a href=/posts>Posts</a></li>
<li><a href=https://www.github.com/zhiruili>Github</a></li>
<li><a href=/index.xml>RSS</a></li>
</ul>
</nav>
<span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span>
<span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg>
</span>
</span>
</span>
</header>
<div class=content>
<div class=post>
<h1 class=post-title>Java Puzzlers</h1>
<div class=post-meta>
<span class=post-date>
2016-08-07
</span>
</div>
<span class=post-tags>
<a href=/tags/java/>#Java</a>&nbsp;
</span>
<div class=post-content>
<h2 id=the-joy-of-sets>The Joy of Sets</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ShortSet</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String args<span style=color:#f92672>[])</span> <span style=color:#f92672>{</span>
    Set<span style=color:#f92672>&lt;</span>Short<span style=color:#f92672>&gt;</span> s <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashSet<span style=color:#f92672>&lt;</span>Short<span style=color:#f92672>&gt;();</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>short</span> i <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span> i <span style=color:#f92672>&lt;</span> 100<span style=color:#f92672>;</span> i<span style=color:#f92672>++)</span> <span style=color:#f92672>{</span>
      s<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>i<span style=color:#f92672>);</span>
      s<span style=color:#f92672>.</span><span style=color:#a6e22e>remove</span><span style=color:#f92672>(</span>i <span style=color:#f92672>-</span> 1<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span>
  <span style=color:#f92672>}</span>
  System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>s<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>());</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>可能会认为这段代码输出的结果是 <code>1</code>，但实际上这段代码输出的结果是 <code>100</code>。</p>
<p>原因在于当调用 <code>i - 1</code> 时，这个计算结果不是 <code>short</code> 类型，而是 <code>int</code> 类型，当调用 <code>s.remove(i - 1)</code> 时，<code>i - 1</code> 的结果会被自动装箱，成为一个 <code>Integer</code> 类型的对象，而不是 <code>Short</code> 类型的对象，这导致 <code>Set&lt;Short> s</code> 中根本没有要删除的对象，所以会出现 <code>100</code> 这个结果。</p>
<p>但为什么当用户想从一个存放 <code>Short</code> 类型对象的 <code>Set</code> 中移除一个 <code>Integer</code> 类型的对象而编译器并没有报错呢？原因是 <code>Set&lt;T></code> 提供的接口声明如下：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>Set</span><span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>extends</span> Collection<span style=color:#f92672>&lt;</span>E<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>E e<span style=color:#f92672>);</span>
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>remove</span><span style=color:#f92672>(</span>Ojbect o<span style=color:#f92672>);</span>
  <span style=color:#f92672>...</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>也就是说，当向一个 <code>Set&lt;Short></code> 对象中添加元素时，编译器会要求用户只能向其中添加 <code>Short</code> 类型的对象，但是移除元素的方法则是可以对任意类型的元素有效，并没有限定是 <code>Short</code> 类型（这个行为是类型安全的）。类似地，<code>Map</code> 的 <code>get</code> 方法声明也是 <code>Object</code> 类型，所以也可以传递任意类型的对象进去。</p>
<p><strong>启示</strong></p>
<ul>
<li><code>Collection&lt;E>.remove</code> 要求 <code>Object</code> 类型的参数而非 <code>E</code>
<ul>
<li>同样地，<code>Collection.contains</code>，<code>Map.get</code> 也是</li>
<li>要注意泛型类的方法的签名</li>
</ul>
</li>
<li>Integral arithmetic 总是返回 <code>int</code> 或是 <code>long</code>
<ul>
<li>永远不会返回 <code>byte</code>、<code>short</code> 或是 <code>char</code></li>
</ul>
</li>
<li>避免混用类型</li>
<li>避免使用 <code>short</code>，最好用 <code>int</code> 和 <code>long</code>
<ul>
<li>只有 <code>short</code> 类型的数组才是 <code>short</code> 类型唯一有意义的用例</li>
</ul>
</li>
</ul>
<h2 id=more-joy-of-sets>More Joy of Sets</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>import</span> java.net.*<span style=color:#f92672>;</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>UrlSet</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String<span style=color:#f92672>[]</span> URL_NAMES <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
    <span style=color:#e6db74>&#34;http://javapuzzlers.com&#34;</span><span style=color:#f92672>,</span>
    <span style=color:#e6db74>&#34;http://apache2-snort.skybar.dreamhost.com&#34;</span><span style=color:#f92672>,</span>
    <span style=color:#e6db74>&#34;http://www.google.com&#34;</span><span style=color:#f92672>,</span>
    <span style=color:#e6db74>&#34;http://javapuzzlers.com&#34;</span><span style=color:#f92672>,</span>
    <span style=color:#e6db74>&#34;http://findbugs.sourceforge.net&#34;</span><span style=color:#f92672>,</span>
    <span style=color:#e6db74>&#34;http://www.cs.umd.edu&#34;</span>
  <span style=color:#f92672>};</span>
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span>
    <span style=color:#66d9ef>throws</span> HalformedURLException <span style=color:#f92672>{</span>
      Set<span style=color:#f92672>&lt;</span>URL<span style=color:#f92672>&gt;</span> favorites <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashSet<span style=color:#f92672>();</span>
      <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>String urlName <span style=color:#f92672>:</span> URL_NAMES<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        favorites<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> URL<span style=color:#f92672>(</span>urlName<span style=color:#f92672>));</span>
      <span style=color:#f92672>}</span>
      System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>favorites<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>());</span>
    <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>可能会认为这段代码输出的结果是 <code>5</code>，但实际上这段代码一般情况下输出的结果是 <code>4</code> 也有可能会出现其他结果。</p>
<p>原因是 <code>URL</code> 类的 <code>equals</code> 和 <code>hashcode</code> 有设计缺陷。</p>
<p>在刚刚的代码中，出现了两次 <code>"http://javapuzzlers.com"</code>，这两个地址是一样的，而它们又和 <code>"http://apache2-snort.skybar.dreamhost.com"</code> 具有同样的 IP 地址。在 <code>URL</code> 类的文档中有提到：</p>
<blockquote>
<ul>
<li><strong>如果两个 <code>URL</code></strong> 有同样的协议、<strong>引用同样的主机</strong>、有同样的端口号且在同一个文件的同一片段上，<strong>那么他们是相等的</strong></li>
<li><strong>如果两个主机名能够解析出同一个 IP 地址，那么这两个主机就是相等的</strong>。如果两个主机都无法解析，那么它们是相等的，或者如果两个主机名都是 <code>null</code> 那他们也是相等的。</li>
</ul>
</blockquote>
<p>这个做法违反了 <code>equals</code> 的协定，因为 <code>equals</code> 应该要与环境无关，而此处 <code>equals</code> 的结果依赖于主机解析，于是，当出现虚拟主机时，这段代码的结果就难以预知。而且 <code>URL</code> 的 <code>equals</code> 的调用还会造成网络 IO，导致阻塞。</p>
<p>正确的做法是，不要使用 <code>URL</code> 类，尽可能使用 <code>URI</code> 类，仅在必要的时候才通过调用 <code>URI</code> 中的方法将其转换为 <code>URL</code> 类的对象。<code>URI</code> 类的 <code>equals</code> 和 <code>hashcode</code> 的实现是正确的，它只依赖于字面地址。换用 <code>URI</code> 之后结果就是 <code>5</code> 了。</p>
<p><strong>启示</strong></p>
<ul>
<li>不要使用 <code>URL</code> 作为 <code>Set</code> 的元素和 <code>Map</code> 的键
<ul>
<li><code>equals</code> 和 <code>hashcode</code> 的实现有错误</li>
<li>它们没有遵从一般的协议</li>
</ul>
</li>
<li>使用 <code>URI</code>
<ul>
<li>在需要的时候将 <code>URI</code> 转为 <code>URL</code></li>
</ul>
</li>
<li>在设计 API 时，要注意 <code>equals</code> 方法不应该依赖于环境</li>
</ul>
<h2 id=racy-little-number>Racy Little Number</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Test</span> <span style=color:#66d9ef>extends</span> junit<span style=color:#f92672>.</span><span style=color:#a6e22e>framework</span><span style=color:#f92672>.</span><span style=color:#a6e22e>TestCase</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>int</span> number<span style=color:#f92672>;</span>

  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>test</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> InterruptedException <span style=color:#f92672>{</span>
    number <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
    Thread t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
        assertEquals<span style=color:#f92672>(</span>2<span style=color:#f92672>,</span> number<span style=color:#f92672>);</span>
      <span style=color:#f92672>}</span>
    <span style=color:#f92672>});</span>
    number <span style=color:#f92672>=</span> 1<span style=color:#f92672>;</span>
    t<span style=color:#f92672>.</span><span style=color:#a6e22e>start</span><span style=color:#f92672>();</span>
    number<span style=color:#f92672>++;</span>
    t<span style=color:#f92672>.</span><span style=color:#a6e22e>join</span><span style=color:#f92672>();</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>可能会认为这个测试有时成功有时失败，但实际上这个测试将永远都通过（但没有告诉我们任何信息）。</p>
<p>原因在于 JUnit 没有机会去看那个 <code>assertEquals(2, number)</code> 的断言是正确的还是错误的。JUnit 只会知道这个方法正常地返回了，所以它会认为这个方法没有出现错误。</p>
<p>解决方案比较麻烦，首先，要定义多一个方法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>volatile</span> Exception exception<span style=color:#f92672>;</span>
<span style=color:#66d9ef>volatile</span> Error error<span style=color:#f92672>;</span>

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>tearDown</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>throws</span> Exception <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>error <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>throw</span> error<span style=color:#f92672>;</span>
  <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>exception <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>throw</span> exception<span style=color:#f92672>;</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>然后在测试的多线程内部这样写：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Thread t <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Thread<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Runnable<span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>try</span> <span style=color:#f92672>{</span>
      assertEquals<span style=color:#f92672>(</span>e<span style=color:#f92672>,</span> number<span style=color:#f92672>);</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span><span style=color:#f92672>(</span>Error e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
      error <span style=color:#f92672>=</span> e<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span> <span style=color:#66d9ef>catch</span><span style=color:#f92672>(</span>Exception e<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
      exception <span style=color:#f92672>=</span> e<span style=color:#f92672>;</span>
    <span style=color:#f92672>}</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>});</span>
</code></pre></div><p>最后再去调用这个 <code>tearDown</code> 方法即可。</p>
<p><strong>启示</strong></p>
<ul>
<li>JUnit 不支持并发</li>
<li>在使用 JUnit 时，你需要自己提供相应的东西去支持并发</li>
</ul>
<h2 id=elvis-lives-again>Elvis Lives Again</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elvis</span> <span style=color:#f92672>{</span>
  <span style=color:#75715e>// Singleton
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Elvis ELVIS <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Elvis<span style=color:#f92672>();</span>

  <span style=color:#66d9ef>private</span> <span style=color:#a6e22e>Elvis</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span> <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Boolean LIVING <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>

  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Boolean alive <span style=color:#f92672>=</span> LIVING<span style=color:#f92672>;</span>

  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> Boolean <span style=color:#a6e22e>lives</span><span style=color:#f92672>()</span>  <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> alive<span style=color:#f92672>;</span> <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>ELVIS<span style=color:#f92672>.</span><span style=color:#a6e22e>lives</span><span style=color:#f92672>()</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;Hound Dog&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Heartbreak Hotel&#34;</span><span style=color:#f92672>);</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>可能会认为这段代码输出的结果是 <code>Hound Dog</code>，但实际上这段代码会抛出一个 <code>NullPointerException</code> 异常。</p>
<p>这个错误的来源是类初始化的过程和自动拆箱。</p>
<p>首先，<code>public static final Elvis ELVIS = new Elvis();</code> 是一个递归的类初始化，然而，<code>private static final Boolean LIVING = true;</code> 这句的执行太晚了，以至于后面得到的只是一个 <code>null</code>。所以当执行 <code>ELVIS.lives() ? "Hound Dog" : "Heartbreak Hotel"</code> 这个自动拆箱的过程时，会抛出异常。</p>
<p>当初始化 <code>Elvis</code> 类时，需要创建 <code>Elvis</code> 类的对象 <code>ELVIS</code>，而创建 <code>Elvis</code> 类的对象又需要初始化 <code>Elvis</code> 类，这时 <code>Elvis</code> 类已经在初始化了，为了防止出现无穷的递归情况，编译器会将类后面的静态域初始化过程忽略而直接去初始化实例域，在这里，实例域只有一个，就是 <code>private final Boolean alive</code>。这个实例域的值是静态常量 <code>LIVING</code>，此时这个静态常量是什么呢？此时由于类还没初始化完成，还没执行到初始化 <code>LIVING</code> 这一句，又因为除了 <code>String</code> 类型对象之外，所有的引用类型对象都不是编译期的常量，所以它的值是 <code>null</code>。在初始化 <code>ELVIS</code> 之后才执行了 <code>LIVING</code> 的初始化，但此时已经太晚了，<code>ELIVIS</code> 的初始化已经结束，<code>null</code> 值已经被复制到了 <code>ELVIS</code> 的实例域 <code>alive</code> 中。</p>
<p>解决方案是交换语句的顺序，使得在 <code>ELVIS</code> 初始化之前先初始化 <code>LIVING</code> 即可：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Elvis</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Boolean LIVING <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span><span style=color:#f92672>;</span>
  <span style=color:#75715e>// Singleton
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> Elvis ELVIS <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Elvis<span style=color:#f92672>();</span>
  <span style=color:#f92672>...</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>另一个解决方案是不要使用 <code>Boolean</code> 直接使用 <code>boolean</code>，因为基本类型有字面常量，不需要等待那个语句的执行。</p>
<p><strong>启示</strong></p>
<ul>
<li>包装后的基本类型不再是基本类型
<ul>
<li>尽可能使用基本类型而非包装后的基本类型</li>
</ul>
</li>
<li>自动拆箱会在最不经意的时候发生
<ul>
<li>而且可能导致 <code>NullPointerException</code></li>
</ul>
</li>
<li>永远不要将 <code>Boolean</code> 对象用于 3 值返回的情况（即：<code>true</code>、<code>false</code> 和 <code>null</code>）</li>
<li>注意环状的类初始化
<ul>
<li>静态实例要在其他类最后进行初始化，不要在其他静态域之前</li>
</ul>
</li>
</ul>
<h2 id=mind-the-gap>Mind the Gap</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>import</span> java.io.*<span style=color:#f92672>;</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Gap</span> <span style=color:#f92672>{</span>
  privagte <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> GAP_SIZE <span style=color:#f92672>=</span> 10 <span style=color:#f92672>*</span> 1024<span style=color:#f92672>;</span>
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String args<span style=color:#f92672>[])</span> <span style=color:#66d9ef>throws</span> IOException <span style=color:#f92672>{</span>
    File tmp <span style=color:#f92672>=</span> File<span style=color:#f92672>.</span><span style=color:#a6e22e>createTempFile</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;gap&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;.txt&#34;</span><span style=color:#f92672>);</span>
    FileOutputStream out <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileOutputStream<span style=color:#f92672>(</span>tmp<span style=color:#f92672>);</span>
    out<span style=color:#f92672>.</span><span style=color:#a6e22e>write</span><span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    out<span style=color:#f92672>.</span><span style=color:#a6e22e>write</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[</span>GAP_SIZE<span style=color:#f92672>]);</span>
    out<span style=color:#f92672>.</span><span style=color:#a6e22e>write</span><span style=color:#f92672>(</span>2<span style=color:#f92672>);</span>
    out<span style=color:#f92672>.</span><span style=color:#a6e22e>close</span><span style=color:#f92672>();</span>
    InputStream in <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedInputStream<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> FileInputStream<span style=color:#f92672>(</span>tmp<span style=color:#f92672>));</span>
    <span style=color:#66d9ef>int</span> first <span style=color:#f92672>=</span> in<span style=color:#f92672>.</span><span style=color:#a6e22e>read</span><span style=color:#f92672>();</span>
    in<span style=color:#f92672>.</span><span style=color:#a6e22e>skip</span><span style=color:#f92672>(</span>GAP_SIZE<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>int</span> last <span style=color:#f92672>=</span> in<span style=color:#f92672>.</span><span style=color:#a6e22e>read</span><span style=color:#f92672>();</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>first <span style=color:#f92672>+</span> last<span style=color:#f92672>);</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>可能会认为这段代码输出的结果是 <code>3</code>，但实际上这段代码在实际情况下输出的结果是 <code>1</code>，而在理论上，它的结果每次运行都会改变。</p>
<p>错误的原因在于 <code>skip</code> 方法。这个方法接受一个 <code>long</code> 类型的值，用于指明需要忽略多少个字节的数据，并且会返回一个 <code>long</code> 值用于说明实际略过了都少个字节。这个返回值很重要，如果随便忽略这个返回值，将很容易导致程序出错，因为它可能没有略过用户要求的字节数。它的 API 只保证 <code>skip</code> 会略过 0 到输入值之间的某个数量的数据，对于 <code>BufferedInputStream</code> 来说，如果缓冲区有数据，它最多只会去略过缓冲区的那些字节，并不往下执行以保证效率。</p>
<p>因此，上面的程序中的 <code>last</code> 并没有读出最后一个数据而是中间的空白，也就是 <code>0</code>。解决方案是定义自己的略过方法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>skipFully</span><span style=color:#f92672>(</span>InputStream in<span style=color:#f92672>,</span> <span style=color:#66d9ef>long</span> nBytes<span style=color:#f92672>)</span> <span style=color:#66d9ef>throws</span> IOException <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>long</span> remaining <span style=color:#f92672>=</span> nBytes<span style=color:#f92672>;</span>
  <span style=color:#66d9ef>while</span> <span style=color:#f92672>(</span>remaining <span style=color:#f92672>!=</span> 0<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>long</span> skipped <span style=color:#f92672>=</span> in<span style=color:#f92672>.</span><span style=color:#a6e22e>skip</span><span style=color:#f92672>(</span>remaining<span style=color:#f92672>);</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>skipped <span style=color:#f92672>==</span> 0<span style=color:#f92672>)</span>
      <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> EOFException<span style=color:#f92672>();</span>
    remaining <span style=color:#f92672>-=</span> skipped<span style=color:#f92672>;</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p><strong>启示</strong></p>
<ul>
<li><code>skip</code> 方法难以使用而且容易产生错误</li>
<li>用自己的略过方法而不要直接使用 <code>skip</code></li>
<li>一般来说，如果一个 API 出错了，就将它包装一下来使用</li>
<li>对于 API 的设计者来说
<ul>
<li>不要违背<strong>最小惊讶原则</strong></li>
<li>要使简单的事情足够易于完成</li>
</ul>
</li>
</ul>
<h2 id=histogram-mystery>Histogram Mystery</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Histogram</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String<span style=color:#f92672>[]</span> words <span style=color:#f92672>=</span>
    <span style=color:#f92672>{</span> <span style=color:#e6db74>&#34;I&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;recommend&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;polygene&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;lubricants&#34;</span> <span style=color:#f92672>};</span>
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> histogram <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>5<span style=color:#f92672>];</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Strign word1 <span style=color:#f92672>:</span> words<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>String word2 <span style=color:#f92672>:</span> words<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
        String pair <span style=color:#f92672>=</span> word1 <span style=color:#f92672>+</span> word2<span style=color:#f92672>;</span>
        <span style=color:#66d9ef>int</span> bucket <span style=color:#f92672>=</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>abs</span><span style=color:#f92672>(</span>pair<span style=color:#f92672>.</span><span style=color:#a6e22e>hashCode</span><span style=color:#f92672>())</span> <span style=color:#f92672>%</span> historgram<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>;</span>
        histogram<span style=color:#f92672>[</span>bucket<span style=color:#f92672>]</span> <span style=color:#f92672>++;</span>
      <span style=color:#f92672>}</span>
    <span style=color:#f92672>}</span>
    <span style=color:#66d9ef>int</span> pairCount <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> freq <span style=color:#f92672>:</span> histogram<span style=color:#f92672>)</span>
      pairCount <span style=color:#f92672>+=</span> freq<span style=color:#f92672>;</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>freq<span style=color:#f92672>);</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>可能会认为这段代码输出的结果是 <code>16</code>，但实际上这段代码会抛出 <code>ArrayOutOfBoundsException</code> 异常。</p>
<p>原因在于 <code>Math.abs(int)</code> 结果可能为负数，且 <code>%</code> 运算符也能产生负数的结果。</p>
<p>此处的字符串是特殊的，因为 <code>"polygenelubricants".hashCode()</code> 的值是 <code>Integer.MIN_VALUE</code>。而且 <code>Math.abs(Integer.MIN_VALUE)</code> 的结果就是 <code>Integer.MIN_VALUE</code>，这是个负数。</p>
<p>解决方法是先进行取余运算，再取绝对值：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>int</span> bucket <span style=color:#f92672>=</span> Math<span style=color:#f92672>.</span><span style=color:#a6e22e>abc</span><span style=color:#f92672>(</span>pair<span style=color:#f92672>.</span><span style=color:#a6e22e>hashCode</span><span style=color:#f92672>()</span> <span style=color:#f92672>%</span> histogram<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>);</span>
</code></pre></div><p><strong>启示</strong></p>
<ul>
<li><code>Math.abs</code> 不保证结果为非负数
<ul>
<li><code>Integer.MIN_VALUE == -Integer.MIN_VALUE</code></li>
</ul>
</li>
<li><code>%</code> 运算符是取余数的运算符而非取模运算符，它也可能得出负数结果</li>
<li>将一个带符号的哈希值映射到桶中时，可以采取如下几种方法：
<ul>
<li><code>Math.abs(hashVal % buckets.length)</code></li>
<li><code>(hashVal >>> 1) % buckets.length</code></li>
<li><code>(hashVal & 0x7fffffff) % buckets.length</code></li>
<li>或使用长度为 2 的指数的数组，这样就可以直接写：<code>(hashVal & (buckets.length - 1))</code> 了</li>
</ul>
</li>
</ul>
<h2 id=a-sea-of-troubles>A Sea of Troubles</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Hamlet</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    Random rnd <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Random<span style=color:#f92672>();</span>
    <span style=color:#66d9ef>boolean</span> toBe <span style=color:#f92672>=</span> rnd<span style=color:#f92672>.</span><span style=color:#a6e22e>nextBoolean</span><span style=color:#f92672>();</span>
    Number result <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>toBe <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>toBe<span style=color:#f92672>)</span> <span style=color:#f92672>?</span> <span style=color:#66d9ef>new</span> Integer<span style=color:#f92672>(</span>3<span style=color:#f92672>)</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> Float<span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>result<span style=color:#f92672>);</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>可能会认为这段代码输出的结果是 <code>3</code>，但实际上这段代码输出的结果是 <code>3.0</code>。</p>
<p>这个错误产生于 <code>?:</code> 操作符在应用于类型不匹配的包装类型时的奇怪行为。当 <code>(toBe || !toBe) ? new Integer(3) : new Float(1)</code> 这个表达式并不是产生一个包裹着 <code>3</code> 的 <code>Integer</code>，而是产生一个包裹着 <code>3</code> 的 <code>Float</code>。</p>
<p>解决方案是如果不确定 <code>?:</code> 操作符的行为，就不要用它，将代码改为：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Number result<span style=color:#f92672>;</span>
<span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>toBe <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>toBe<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
  result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Integer<span style=color:#f92672>(</span>3<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span> <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
  result <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Float<span style=color:#f92672>(</span>1<span style=color:#f92672>);</span>
<span style=color:#f92672>}</span>
</code></pre></div><p><strong>启示</strong></p>
<ul>
<li>避免混用类型</li>
<li><code>?:</code> 操作符在操作两个不同的包装类型时会有违反直觉的语义</li>
<li>如果一定要在两个包装类型的值之间进行选择，不要用 <code>?:</code> 操作符，而应该使用 <code>if-else</code></li>
</ul>
<h2 id=ground-round>Ground Round</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Round</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    Random rnd <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Random<span style=color:#f92672>();</span>
    <span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> rnd<span style=color:#f92672>.</span><span style=color:#a6e22e>nextInt</span><span style=color:#f92672>();</span>
    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>Math<span style=color:#f92672>.</span><span style=color:#a6e22e>round</span><span style=color:#f92672>(</span>i<span style=color:#f92672>)</span> <span style=color:#f92672>!=</span> i<span style=color:#f92672>)</span>
      System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Ground Round&#34;</span><span style=color:#f92672>);</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>可能会认为这个程序永远都不会打印出 <code>Ground Round</code>，但事实上，这个程序有非常高的概率（大约 96.7%）会打印这个字符串。</p>
<p>原因在于，<code>round</code> 没有在 <code>int</code> 类型的参数上进行重载，它只有两个重载版本：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>round</span><span style=color:#f92672>(</span><span style=color:#66d9ef>float</span><span style=color:#f92672>);</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>round</span><span style=color:#f92672>(</span><span style=color:#66d9ef>double</span><span style=color:#f92672>);</span>
</code></pre></div><p>当传入 <code>int</code> 类型的值时，参数类型为 <code>float</code> 的版本将会被调用。由于 <code>float</code> 有 8 bits 的指数位，所以这个转换过程损失了精度。这是一个语言设计的错误，一般来说，不应该在这种有损精度的隐式转换下不报错或不提示警告。</p>
<p>解决方案是将其强制转换为 <code>double</code> 使得 <code>double</code> 的重载版本被调用，由于 <code>double</code> 是 64 bits 的，所以这个转换过程并不会损失精度。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Math<span style=color:#f92672>.</span><span style=color:#a6e22e>round</span><span style=color:#f92672>((</span><span style=color:#66d9ef>double</span><span style=color:#f92672>)</span> i<span style=color:#f92672>)</span> <span style=color:#f92672>!=</span> i
</code></pre></div><p><strong>启示</strong></p>
<ul>
<li>从 <code>int</code> 到 <code>float</code> 的静默<strong>放宽</strong>转换是有损的且危险的
<ul>
<li>类似地，从 <code>long</code> 到 <code>double</code> 也是</li>
</ul>
</li>
<li><code>float</code> 类型很少被使用，尽可能用 <code>double</code>。除非有一个很大的 <code>float</code> 数组</li>
<li>方法的重载是危险的，尤其是出现隐式的<strong>放宽</strong>时</li>
</ul>
<h2 id=size-matters>Size Matters</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Size</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>enum</span> Sex <span style=color:#f92672>{</span> MALE<span style=color:#f92672>,</span> FEMALE <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>print</span><span style=color:#f92672>(</span>size<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;</span>Sex<span style=color:#f92672>,</span> Sex<span style=color:#f92672>&gt;())</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span><span style=color:#f92672>);</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>print</span><span style=color:#f92672>(</span>size<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> EnumMap<span style=color:#f92672>&lt;</span>Sex<span style=color:#f92672>,</span> Sex<span style=color:#f92672>&gt;(</span>Sex<span style=color:#f92672>.</span><span style=color:#a6e22e>class</span><span style=color:#f92672>)));</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>size</span><span style=color:#f92672>(</span>Map<span style=color:#f92672>&lt;</span>Sex<span style=color:#f92672>,</span> Sex<span style=color:#f92672>&gt;</span> map<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    map<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>Sex<span style=color:#f92672>.</span><span style=color:#a6e22e>MALE</span><span style=color:#f92672>,</span> Sex<span style=color:#f92672>.</span><span style=color:#a6e22e>FEMALE</span><span style=color:#f92672>);</span>
    map<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>Sex<span style=color:#f92672>.</span><span style=color:#a6e22e>FEMALE</span><span style=color:#f92672>,</span> Sex<span style=color:#f92672>.</span><span style=color:#a6e22e>MALE</span><span style=color:#f92672>);</span>
    map<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>Sex<span style=color:#f92672>.</span><span style=color:#a6e22e>MALE</span><span style=color:#f92672>,</span> Sex<span style=color:#f92672>.</span><span style=color:#a6e22e>MALE</span><span style=color:#f92672>);</span>
    map<span style=color:#f92672>.</span><span style=color:#a6e22e>put</span><span style=color:#f92672>(</span>Sex<span style=color:#f92672>.</span><span style=color:#a6e22e>FEMALE</span><span style=color:#f92672>,</span> Sex<span style=color:#f92672>.</span><span style=color:#a6e22e>FEMALE</span><span style=color:#f92672>);</span>
    Set<span style=color:#f92672>&lt;</span>Map<span style=color:#f92672>.</span><span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>Sex<span style=color:#f92672>,</span> Sex<span style=color:#f92672>&gt;&gt;</span> set <span style=color:#f92672>=</span>
      <span style=color:#66d9ef>new</span> HashSet<span style=color:#f92672>&lt;</span>Map<span style=color:#f92672>.</span><span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>Sex<span style=color:#f92672>,</span> Sex<span style=color:#f92672>&gt;&gt;(</span>map<span style=color:#f92672>.</span><span style=color:#a6e22e>entrySet</span><span style=color:#f92672>());</span>
    <span style=color:#66d9ef>return</span> set<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>可能会认为这个程序将打印出 <code>2 2</code> 但它将打印出 <code>2 1</code>。</p>
<p>原因在于 <code>EnumMap</code> 的 <code>entrySet</code> 方法总返回同一个 <code>Entry</code> 类型的对象。所以，解决方案是将 entries 复制出来并手动插入：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>...</span>
Set<span style=color:#f92672>&lt;</span>Map<span style=color:#f92672>.</span><span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>Sex<span style=color:#f92672>,</span> Sex<span style=color:#f92672>&gt;&gt;</span> set <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashSet<span style=color:#f92672>&lt;</span>Map<span style=color:#f92672>.</span><span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>Sex<span style=color:#f92672>,</span> Sex<span style=color:#f92672>&gt;&gt;();</span>
<span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Map<span style=color:#f92672>.</span><span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>Sex<span style=color:#f92672>,</span> Sex<span style=color:#f92672>&gt;</span> e <span style=color:#f92672>:</span> map<span style=color:#f92672>.</span><span style=color:#a6e22e>entrySet</span><span style=color:#f92672>())</span>
  set<span style=color:#f92672>.</span><span style=color:#a6e22e>add</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> AbstractMap<span style=color:#f92672>.</span><span style=color:#a6e22e>SimpleImmutableEntry</span><span style=color:#f92672>&lt;</span>Sex<span style=color:#f92672>,</span> Sex<span style=color:#f92672>&gt;(</span>e<span style=color:#f92672>));</span>
<span style=color:#66d9ef>return</span> set<span style=color:#f92672>.</span><span style=color:#a6e22e>size</span><span style=color:#f92672>();</span>
</code></pre></div><p>这样处理后，结果就为 <code>2 2</code> 了。</p>
<p><strong>启示</strong></p>
<ul>
<li>在 <code>entrySet</code> 上进行迭代遍历需要小心
<ul>
<li><code>Iterator</code> 前进时，<code>Entry</code> 可能失效</li>
<li>JDK 6 的 <code>Map</code> 实现中，只有 <code>EnumMap</code> 和 <code>IdentityHashMap</code> 有这样的行为
<ul>
<li>Android 的 <code>Map</code> 实现中没有这样的行为</li>
</ul>
</li>
<li><code>new HashSet&lt;EntryType>(map.entrySet())</code> 这一惯例将在面对这一行为时失效</li>
</ul>
</li>
<li>对于 API 设计者来说
<ul>
<li>不要违背<strong>最小惊讶原则</strong></li>
<li>除非别无选择，不要以恶化 API 为代价来提升性能
<ul>
<li>这可能在当时是一个看起来好的选择，但你迟早会后悔的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id=the-match-game>The Match Game</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#f92672>import</span> java.util.regex.*<span style=color:#f92672>;</span>
<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Match</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    Pattern p <span style=color:#f92672>=</span> Pattern<span style=color:#f92672>.</span><span style=color:#a6e22e>compile</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;(aa|aab?)+&#34;</span><span style=color:#f92672>);</span>
    <span style=color:#66d9ef>int</span> count <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>for</span><span style=color:#f92672>(</span>String s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>;</span> s<span style=color:#f92672>.</span><span style=color:#a6e22e>length</span><span style=color:#f92672>()</span> <span style=color:#f92672>&lt;</span> 200<span style=color:#f92672>;</span> s <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;a&#34;</span><span style=color:#f92672>)</span>
      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>p<span style=color:#f92672>.</span><span style=color:#a6e22e>matcher</span><span style=color:#f92672>(</span>s<span style=color:#f92672>).</span><span style=color:#a6e22e>matches</span><span style=color:#f92672>())</span>
        count<span style=color:#f92672>++;</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>count<span style=color:#f92672>);</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>可能会认为这个程序将打印出 <code>100</code> 但它并不会输出任何结果，因为 <strong>catastrophic backtracking</strong> 导致其计算时间超过 1015 年。</p>
<p>正则表达式匹配的本质是构建了一个 DFA，而对于这段代码而言，它将产生一个二叉树，对于任意的奇数个 <code>a</code> 构成的字符串，匹配过程将会遍历整个二叉树的叶子节点，而其复杂度为 $O(2^{n/2})$。这不是 Java 的问题，而是所有支持回溯的正则表达式匹配引擎共有的问题。这个问题没有什么解决方式，只能是在使用正则表达式的时候想清楚其代价。另外，由于正则表达式本身就很容易产生错误，所以尽量少用正则表达式。</p>
<h2 id=that-sinking-feeling>That Sinking Feeling</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Sink</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>T<span style=color:#f92672>...</span> elements<span style=color:#f92672>);</span>
  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addUnlessnull</span><span style=color:#f92672>(</span>T<span style=color:#f92672>...</span> elements<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>T element <span style=color:#f92672>:</span> elements<span style=color:#f92672>)</span>
      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>element <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
        add<span style=color:#f92672>(</span>element<span style=color:#f92672>)</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StringSink</span> <span style=color:#66d9ef>extends</span> Sink<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;();</span>
  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>String<span style=color:#f92672>...</span> elements<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    list<span style=color:#f92672>.</span><span style=color:#a6e22e>addAll</span><span style=color:#f92672>(</span>Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>asList</span><span style=color:#f92672>(</span>elements<span style=color:#f92672>));</span>
  <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>();</span> <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    Sink<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> ss <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringSink<span style=color:#f92672>();</span>
    ss<span style=color:#f92672>.</span><span style=color:#a6e22e>addUnlessNull</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;null&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>);</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>ss<span style=color:#f92672>);</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>可能会认为这个程序将打印出 <code>[null]</code> 但它将抛出一个 <code>ClassCastException</code>。</p>
<p>产生的原因有几个，包括可变长参数列表、类型擦除和桥接方法。</p>
<p>当在 <code>abstract class Sink&lt;T></code> 中声明 <code>abstract void add(T... elements)</code> 和 <code>void addUnlessNull(T... elements) { ... }</code> 时，由于类型擦除以及可变长参数列表的实现，实际上声明的参数类型是 <code>Object[]</code>。在 <code>addUnlessNull</code> 方法内部，调用了 <code>add(element)</code> 方法，这个 <code>element</code> 在传入的时候构建的是一个长度为 <code>1</code> 的 <code>Object[]</code> 对象，并非 <code>T[]</code>。</p>
<p>而在 <code>StringSink</code> 内部，编译器会生成一个桥接方法：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StringSink</span> <span style=color:#66d9ef>extends</span> Sink<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
  <span style=color:#f92672>...</span>
  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>Object<span style=color:#f92672>[]</span> a<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    add<span style=color:#f92672>((</span>String<span style=color:#f92672>[])</span> a<span style=color:#f92672>);</span>
  <span style=color:#f92672>}</span>
  <span style=color:#f92672>...</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>这个 <code>void add(Object[] a)</code> 方法覆盖了抽象类中的那个抽象方法 <code>abstract void add(T... elements)</code>，并在 <code>add((String[]) a)</code> 处对 <code>a</code> 进行了强制类型转换。</p>
<p>当程序执行到 <code>ss.addUnlessNull("null", null)</code> 这一句时，编译器其实是构建了一个 <code>String[]</code> 类型的对象，然后在 <code>add((String[]) a)</code> 处因为强制类型转换而出现了 <code>ClassCastException</code> 这个异常。</p>
<p>解决方案是避免使用变长参数列表和数组，而应该使用集合。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Sink</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>Collection<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> elements<span style=color:#f92672>);</span>
  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addUnlessnull</span><span style=color:#f92672>(</span>Collection<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> elements<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>T element <span style=color:#f92672>:</span> elements<span style=color:#f92672>)</span>
      <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>element <span style=color:#f92672>!=</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>)</span>
        add<span style=color:#f92672>(</span>Collections<span style=color:#f92672>.</span><span style=color:#a6e22e>singleton</span><span style=color:#f92672>(</span>element<span style=color:#f92672>))</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StringSink</span> <span style=color:#66d9ef>extends</span> Sink<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> list <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;();</span>
  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span><span style=color:#f92672>(</span>Collection<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> elements<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    list<span style=color:#f92672>.</span><span style=color:#a6e22e>addAll</span><span style=color:#f92672>(</span>elements<span style=color:#f92672>);</span>
  <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>public</span> String <span style=color:#a6e22e>toString</span><span style=color:#f92672>()</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>return</span> list<span style=color:#f92672>.</span><span style=color:#a6e22e>toString</span><span style=color:#f92672>();</span> <span style=color:#f92672>}</span>
  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String<span style=color:#f92672>[]</span> args<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    Sink<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> ss <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringSink<span style=color:#f92672>();</span>
    ss<span style=color:#f92672>.</span><span style=color:#a6e22e>addUnlessNull</span><span style=color:#f92672>(</span>Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>asList</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;null&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>null</span><span style=color:#f92672>));</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>ss<span style=color:#f92672>);</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>此时程序将不会构建桥接方法，并将输出 <code>[null]</code>。</p>
<p><strong>启示</strong></p>
<ul>
<li>可变长参数列表提供了一个有漏洞的抽象</li>
<li>泛型和数组无法很好地协同工作
<ul>
<li>所以泛型和可变长参数列表无法很好地协同工作</li>
</ul>
</li>
<li>尽量不要使用数组而应该使用集合类
<ul>
<li>尤其是 API 设计的时候</li>
</ul>
</li>
<li>不要忽略编译器的警告
<ul>
<li>原先有漏洞的代码会产生编译器的警告</li>
<li>理想状况下，尽可能通过改善代码来消除编译器警告，如果做不到的话：
<ul>
<li>证明实际上不存在问题并将证明写在注释中</li>
<li>局部使用 <code>@SuppressWarnings</code> 注解消除警告</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id=glommer-pile>Glommer Pile</h2>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Glommer</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>{</span>
  String <span style=color:#a6e22e>glom</span><span style=color:#f92672>(</span>Clooection<span style=color:#f92672>&lt;?&gt;</span> objs<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    String result <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span><span style=color:#f92672>;</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span>Object o <span style=color:#f92672>:</span> objs<span style=color:#f92672>)</span>
      result <span style=color:#f92672>+=</span> o<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>glom</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> ints<span style=color:#f92672>)</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> 0<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>for</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>int</span> i <span style=color:#f92672>:</span> ints<span style=color:#f92672>)</span>
      result <span style=color:#f92672>+=</span> i<span style=color:#f92672>;</span>
    <span style=color:#66d9ef>return</span> result<span style=color:#f92672>;</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String args<span style=color:#f92672>[])</span> <span style=color:#f92672>{</span>
    List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> strings <span style=color:#f92672>=</span> Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>asList</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;2&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;3&#34;</span><span style=color:#f92672>);</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Glommer<span style=color:#f92672>().</span><span style=color:#a6e22e>glom</span><span style=color:#f92672>(</span>strings<span style=color:#f92672>));</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>可能会认为这个程序将打印出 <code>123</code> 但它将抛出一个 <code>ClassCastException</code>。</p>
<p>原因在于，类声明时虽然声明了一个类型参数 <code>T</code>，但实际上并没有在类 <code>Glommer</code> 中使用到这个类型参数。在调用 <code>new Glommer()</code> 的时候，由于没有指定类型参数，所以实际上创建的是 <code>Glommer&lt;T></code> 的原始类型（也就是 <code>Glommer</code>）的对象，而泛型类的原始类型会忽略所有泛型类内部的类型参数信息，即相当于：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Glommer</span> <span style=color:#f92672>{</span>
  String <span style=color:#a6e22e>glom</span><span style=color:#f92672>(</span>Clooection objs<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>glom</span><span style=color:#f92672>(</span>List ints<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String args<span style=color:#f92672>[])</span> <span style=color:#f92672>{</span>
    List strings <span style=color:#f92672>=</span> Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>asList</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;2&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;3&#34;</span><span style=color:#f92672>);</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Glommer<span style=color:#f92672>().</span><span style=color:#a6e22e>glom</span><span style=color:#f92672>(</span>strings<span style=color:#f92672>));</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p>这导致了 <code>int glom(List ints)</code> 的重载版本成为了最为准确的重载版本，所以编译器选择了调用这个版本的 <code>glom</code>。</p>
<p>解决方法是在创建 <code>Glommer&lt;T></code> 类型的对象时指定一个类型参数，对于这个例子而言，由于类型参数 <code>T</code> 并未在 <code>Glommer&lt;T></code> 中被使用，所以随便指定一个就可以了，例如：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> Glommer<span style=color:#f92672>&lt;</span>Random<span style=color:#f92672>&gt;().</span><span style=color:#a6e22e>glom</span><span style=color:#f92672>(</span>strings<span style=color:#f92672>));</span>
</code></pre></div><p>当然，由于此处根本没用到类型参数，一开始就不要去声明这个类型参数就是一个更好的选择：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Glommer</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
</code></pre></div><p>这里还可以进行进一步的优化，由于此处两个方法连实例的域都没有用到，所以可以直接将其声明为静态的：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Glommer</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>glom</span><span style=color:#f92672>(</span>Clooection<span style=color:#f92672>&lt;?&gt;</span> objs<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>glom</span><span style=color:#f92672>(</span>List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> ints<span style=color:#f92672>)</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span><span style=color:#f92672>(</span>String args<span style=color:#f92672>[])</span> <span style=color:#f92672>{</span>
    List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> strings <span style=color:#f92672>=</span> Arrays<span style=color:#f92672>.</span><span style=color:#a6e22e>asList</span><span style=color:#f92672>(</span><span style=color:#e6db74>&#34;1&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;2&#34;</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;3&#34;</span><span style=color:#f92672>);</span>
    System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>(</span>glom<span style=color:#f92672>(</span>strings<span style=color:#f92672>));</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>
</code></pre></div><p><strong>启示</strong></p>
<ul>
<li>永远不要在新的代码中使用泛型类的原始类型</li>
<li>泛型类的原始类型将失去<strong>全部</strong>泛型的类型信息
<ul>
<li>这可能导致重载到意想不到的方法上</li>
</ul>
</li>
<li>不要忽视编译器警告，即便它们难以阅读
<ul>
<li>错误版本的代码会产生一个编译警告</li>
<li>未受检的警告意味着自动生成的转换可能会在运行时失败</li>
</ul>
</li>
</ul>
<h2 id=源视频>源视频</h2>
<p><a href="https://www.youtube.com/watch?v=wDN_EYUvUq0">Advanced Topics in Programming Languages: Java Puzzlers,&mldr;</a>
<a href="https://www.youtube.com/watch?v=wbp-3BJWsU8">Google I/O 2011: Java Puzzlers - Scraping the Bottom of the Barrel</a></p>
</div>
<div class=pagination>
<div class=pagination__title>
<span class=pagination__title-h>Read other posts</span>
<hr>
</div>
<div class=pagination__buttons>
<span class="button previous">
<a href=/posts/handle-concurrency-using-future/>
<span class=button__icon>←</span>
<span class=button__text>使用 Future 进行并发编程</span>
</a>
</span>
<span class="button next">
<a href=/posts/null-value-and-handling/>
<span class=button__text>Null 值及其处理方式</span>
<span class=button__icon>→</span>
</a>
</span>
</div>
</div>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//ZhiruiLi.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user"><p>本网站采用 <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a> 协议进行授权</p><p>© 2021 Zhirui Li. All rights reserved.</p></div>
</div>
</footer>
<script src=/assets/main.js></script>
<script src=/assets/prism.js></script><p>我的博客即将同步至腾讯云+社区，<a target=_blank href="https://cloud.tencent.com/developer/support-plan?invite_code=11dehb9vzutlx">邀请大家一同入驻</a>。</p>
</div>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-80302213-1','auto'),ga('send','pageview'))</script>
</body>
</html>