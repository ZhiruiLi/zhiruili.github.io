<!doctype html><html lang=cn><head><title>AI 届新语言 Mojo 要🔥？ ::
简易现代魔法 — Zhirui Li's Blog</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Mojo 语言简介 # 这个标题里放一个 emoji 有点哗众取宠的意思，但真不是我想放，而是 Mojo 这语言自己的官网就长这样 1。而且，这语言的标准文件后缀一个是「.mo"><meta name=keywords content="编程,计算机图形学,游戏开发"><meta name=robots content="noodp"><link rel=canonical href=/posts/mojo-lang/><link rel=stylesheet href=/assets/style.css><link rel=stylesheet href=/style.css><link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png><link rel="shortcut icon" href=/img/favicon.png><link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin><link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin><meta name=twitter:card content="summary"><meta name=twitter:title content="AI 届新语言 Mojo 要🔥？"><meta name=twitter:description content="Mojo 语言简介 # 这个标题里放一个 emoji 有点哗众取宠的意思，但真不是我想放，而是 Mojo 这语言自己的官网就长这样 1。而且，这语言的标准文件后缀一个是「.mo"><meta property="og:title" content="AI 届新语言 Mojo 要🔥？"><meta property="og:description" content="Mojo 语言简介 # 这个标题里放一个 emoji 有点哗众取宠的意思，但真不是我想放，而是 Mojo 这语言自己的官网就长这样 1。而且，这语言的标准文件后缀一个是「.mo"><meta property="og:type" content="article"><meta property="og:url" content="/posts/mojo-lang/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-29T00:00:00+00:00"><meta property="article:modified_time" content="2023-07-30T00:00:00+00:00"><script>var posts=document.getElementById("posts-list");posts&&quicklink({el:posts,priority:!0})</script><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><div class=container><header class=header><span class=header__inner><a href=/ class=logo style=text-decoration:none><span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg></span><span class=logo__text>简易现代魔法</span>
<span class=logo__cursor></span></a>
<span class=header__right><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/archive>Archive</a></li><li><a href=/tags>Tags</a></li><li><a href=https://www.github.com/zhiruili>Github</a></li><li><a href=/index.xml>RSS</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/archive>Archive</a></li><li><a href=/tags>Tags</a></li><li><a href=https://www.github.com/zhiruili>Github</a></li><li><a href=/index.xml>RSS</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><div class=post><h1 class=post-title>AI 届新语言 Mojo 要🔥？</h1><div class=post-meta><span class=post-date>2023-07-29</span></div><span class=post-tags><a href=/tags/ai/>#AI</a>&nbsp;
<a href=/tags/mojo/>#Mojo</a>&nbsp;</span><div class=post-content><h2 id=mojo-语言简介>Mojo 语言简介
<a href=#mojo-%e8%af%ad%e8%a8%80%e7%ae%80%e4%bb%8b class=h-anchor aria-hidden=true>#</a></h2><p>这个标题里放一个 emoji 有点哗众取宠的意思，但真不是我想放，而是 Mojo 这语言自己的官网就长这样 <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。而且，这语言的标准文件后缀一个是「.mojo」另一个就是「.🔥」。说实话，这个操作其实挺无聊的，也有点败好感，但如果说这个语言能在完全兼容 Python 的基础上大幅提高执行效率，并且作者是 LLVM 发起人 Chris Lattner <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，是不是突然又有兴趣继续了解它了呢？Mojo 被设计为 Python 语言的超集，并增加了许多特性，包括：</p><ul><li>Progressive types：能利用类型信息获得更好性能和静态检查，但又不强制要求写类型</li><li>Zero cost abstractions：C++ 的核心设计准则，能够避免用户为了性能放弃合理设计的代码</li><li>Ownership + borrow checker：Rust 语言的安全性来源，在编译期避免许多错误的发生</li><li>The full power of MLIR：原生支持对 MLIR 的直接访问，能够从底层扩展系统</li></ul><p>除此之外，Mojo 还有很多别的特性，如编译期元编程、自动参数选择等等，在这篇文章中我们将略窥一二。在这之前，还是让我们先来看看为什么我们需要一个新语言吧。</p><h2 id=为-ai-而生的语言>为 AI 而生的语言
<a href=#%e4%b8%ba-ai-%e8%80%8c%e7%94%9f%e7%9a%84%e8%af%ad%e8%a8%80 class=h-anchor aria-hidden=true>#</a></h2><p>在 Mojo 这个语言的介绍中反复提到 AI，官网也说它是「a new programming language for all AI developers」。那么为什么 AI 开发需要一个新语言呢？首先，我们知道在 AI 届具有统治地位的语言就是 Python，Python 是一个语法简单清晰，容易上手，且灵活度很高的语言，深受广大程序员喜爱，XKCD 上有就这么一幅漫画 <sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>：</p><p><img src=/images/xkcd_python.png alt="xkcd python"></p><p>当然，受人喜爱的语言有很多，Python 成为 AI 届的统治语言除了本身易用之外，也有惯性的因素。由于 Python 上机器学习相关的库多，因此机器学习从业者用的就多，这又反过来令新的机器学习相关库优先为 Python 提供接口，进一步加强了其统治地位。因此，为了逐步渗透这个用户群，Mojo 兼容 Python 是很正确的一个选择。Mojo 不仅承诺语法是 Python 的超集，并且它还能直接调用 Python 的库，这意味着 Mojo 不需要从零开始构建自己的生态，本身就可以用上繁荣的 Python 生态了。</p><p>虽然 Python 很好，但它有一个众所周知的问题，那就是太慢了。而机器学习本身又需要繁重的计算，因此 Python 生态中大量库的底层其实都是用高性能的语言（如 C/C++）进行实现，然后再提供一个 Python 接口供用户调用，典型的如 numpy 这种数学库。在这种情况下，Python 事实上是被作为一个胶水语言来使用，这造成了开发的碎片化，如果一个用户只是简单调一下库那还好说，但一旦到了工业界，开发过程中不可避免地就要涉及一些底层库的修改，甚至直接换语言来实现同样的功能以提高性能，这种割裂不止增加了开发成本和精神负担，而且考虑到众多擅长 C/C++ 语言的开发者也并不是 AI 领域专家，这种开发人员能力的不适配也对整个 AI 生态的发展形成了一定阻碍。</p><p>因此，Mojo 的目的就是要在 Python 生态的基础上，让用户能用一个语言，从使用易用的接口，到开发复杂的库，再到实现底层黑科技，统一实验和生产环境所用的语言。为了实现这个目的，Mojo 扩展了 Python 语法，支持了紧凑的内存布局，并引入了一些现代的语言特性（例如 Rust 的安全性检查），使得这个语言能够渐进式地在 AI 届立足。说起来 Chris Lattner 在这方面可以算是经验丰富了，不管是在 gcc/msvc 的统治下实现 clang，还是在 objective-c 的统治下为苹果实现 swift，都是一个逐步蚕食对手市场的过程。</p><h2 id=mojo-长什么样>Mojo 长什么样
<a href=#mojo-%e9%95%bf%e4%bb%80%e4%b9%88%e6%a0%b7 class=h-anchor aria-hidden=true>#</a></h2><p>说了这么多，该来看看 Mojo 长什么样了。现在 Mojo 还不能直接下载使用，如果想要尝鲜，需要在<a href=https://www.modular.com/get-started>官网</a>申请，然后在 <a href=https://playground.modular.com/>playground 页面</a>中试用，这是一个基于 Jupyter 的页面，可以混合笔记和可执行的 Mojo 代码。</p><p>前面提到，Mojo 的语法是 Python 的超集，因此 Mojo 的 Hello World 也跟 Python 一样简单：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(<span style=color:#e6db74>&#34;Hello World&#34;</span>)  <span style=color:#75715e>#&gt; Hello World</span>
</span></span></code></pre></div><p>与 Python 一样，Mojo 也使用换行符和缩进来定义代码块：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>fn foo():
</span></span><span style=display:flex><span>    var x: Int <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    x <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    let y: Int <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    print(x, y)  <span style=color:#75715e>#&gt; 2 1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>foo()
</span></span></code></pre></div><p>上面的代码中使用 <code>var</code> 来声明变量 <code>x</code>，使用 <code>let</code> 来声明了不可变量 <code>y</code>。Mojo 像很多较新近的语言一样，让不可变量的声明变得简单，以鼓励开发者使用不可变的量。另外注意到这里定义函数使用了 <code>fn</code> 而非 Python 的 <code>def</code>，这是因为 Mojo 希望在兼容 Python 的基础上加入编译期的检查和优化，而 Python 过于动态的语法很难支持这一目标，因此，Mojo 同时支持使用 <code>fn</code> 和 <code>def</code> 两个关键字来声明函数，对于调用者来说，这两种方法声明出来的函数没有什么区别，但对于实现者来说，可以将 <code>fn</code> 看作「严格模式」下的 <code>def</code>，例如下面的代码会编译错误（如果改成用 <code>def</code> 则不会出错）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>fn foo():
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    print(x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># error: Expression [12]:6:5: use of unknown declaration &#39;x&#39;, &#39;fn&#39; declarations require explicit variable declarations</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#    x = 1</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#    ^</span>
</span></span></code></pre></div><p>虽然官方承诺 Mojo 的语法是 Python 的超集，但目前 Mojo 还在开发中，很多 Python 语法都还不支持，例如目前连 Python 的 <code>class</code> 都无法被编译通过：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyClass</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>():
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># error: Expression [15]:17:5: classes are not supported yet</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     class MyClass:</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#     ^</span>
</span></span></code></pre></div><p>不过，Mojo 现在先提供了另一个用来组织数据的关键字 <code>struct</code>，相比与 <code>class</code>，<code>struct</code> 更加静态可控，便于优化。一方面，<code>struct</code> 支持类似 Python <code>class</code> 风格的函数声明和运算符重载。而另一方面，<code>struct</code> 又类似于 C++ 的 <code>struct</code> 和 <code>class</code>，内部的成员在内存中紧凑排布，而且不支持在运行时动态添加成员和方法，便于编译期进行优化，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>struct MyIntPair:
</span></span><span style=display:flex><span>    var first: Int
</span></span><span style=display:flex><span>    var second: Int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fn __init__(inout self, first: Int, second: Int):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>first <span style=color:#f92672>=</span> first
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>second <span style=color:#f92672>=</span> second
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fn __lt__(self, rhs: MyIntPair) <span style=color:#f92672>-&gt;</span> Bool:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>first <span style=color:#f92672>&lt;</span> rhs<span style=color:#f92672>.</span>first <span style=color:#f92672>or</span>
</span></span><span style=display:flex><span>              (self<span style=color:#f92672>.</span>first <span style=color:#f92672>==</span> rhs<span style=color:#f92672>.</span>first <span style=color:#f92672>and</span>
</span></span><span style=display:flex><span>               self<span style=color:#f92672>.</span>second <span style=color:#f92672>&lt;</span> rhs<span style=color:#f92672>.</span>second)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let p1 <span style=color:#f92672>=</span> MyIntPair(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>let p2 <span style=color:#f92672>=</span> MyIntPair(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> p1 <span style=color:#f92672>&lt;</span> p2: print(<span style=color:#e6db74>&#34;p1 &lt; p2&#34;</span>)  <span style=color:#75715e>#&gt; p1 &lt; p2</span>
</span></span></code></pre></div><p>虽然有点不同，但整体上看起来还是非常熟悉的对吧。说到这里，有一点需要提醒各位注意，尽管 Mojo 之后会令语法成为 Python 语法的超集，但其语义则有时会和 Python 不同，这意味着 Python 的代码直接拷到 Mojo 里可能会出现编译通过但执行结果不同的情况，这里简单提一个比较常见的例子：函数传参。在 Python 中，函数传参的语义类似于 C++ 的传指针，在函数内部虽然不能更改调用者指向的对象，但可以改变该对象内部的状态，例如下面的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>(lst):
</span></span><span style=display:flex><span>    lst[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>    print(lst)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>x <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>]
</span></span><span style=display:flex><span>foo(x)
</span></span><span style=display:flex><span>print(x)
</span></span></code></pre></div><p>在 Python 中，这段代码打印出来的结果是两次 <code>[5, 2, 3]</code>。但在 Mojo 中，使用 <code>def</code> 定义的函数默认的传递逻辑是复制值，也就是说，尽管在函数中能够修改参数内部的状态，但修改对于调用方来说是不可见的，因此上面这段代码在 Mojo 中打印的结果是 <code>[5, 2, 3]</code>（<code>foo</code> 内部）和 <code>[1, 2, 3]</code>（<code>foo</code> 外部）。</p><p>除了语法像 Python，Mojo 非常务实的一点在于它构建于 Python 的生态之上。因此即便 Mojo 还没能完整支持 Python 的语法，它还是优先支持了对 Python 库的调用，以便让开发者能受益于庞大完善的 Python 的生态。例如下面的代码就使用了 Python 的 numpy 库：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> PythonInterface <span style=color:#f92672>import</span> Python
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>let np <span style=color:#f92672>=</span> Python<span style=color:#f92672>.</span>import_module(<span style=color:#e6db74>&#34;numpy&#34;</span>)
</span></span><span style=display:flex><span>ar <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>arange(<span style=color:#ae81ff>15</span>)<span style=color:#f92672>.</span>reshape(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>print(ar<span style=color:#f92672>.</span>shape)   <span style=color:#75715e>#&gt; (3, 5)</span>
</span></span></code></pre></div><h2 id=博采众长又有所创新>博采众长又有所创新
<a href=#%e5%8d%9a%e9%87%87%e4%bc%97%e9%95%bf%e5%8f%88%e6%9c%89%e6%89%80%e5%88%9b%e6%96%b0 class=h-anchor aria-hidden=true>#</a></h2><p>Mojo 作为一个新语言，广泛吸收许多现代的程序语言设计思想，例如 Rust 的所有权和借用检查，以此提升代码的安全性。在 Mojo 中，使用 <code>fn</code> 定义的函数的参数默认传的是不可变的引用，即「借用」，调用方仍然拥有其所有权，因此在函数内部不可以对参数进行修改。Mojo 提供了一个 <code>borrow</code> 关键字来标注这样的参数传递情况，对于 <code>fn</code> 来说是可以省略的，也就是说下面 <code>foo</code> 函数中两个参数的传递方式相同：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>fn foo(borrowed a: SomethingBig, b: SomethingBig):
</span></span><span style=display:flex><span>    a<span style=color:#f92672>.</span>use()
</span></span><span style=display:flex><span>    b<span style=color:#f92672>.</span>use()
</span></span></code></pre></div><p>在 Rust 中，传参的默认行为是移动，如果需要借用则需要在传入时加上 <code>&</code>，这两种方式倒是没有太大的优劣之分，Mojo 的行为可能更接近于 Python 这类高级语言的习惯。如果想要修改传入的参数，则需要手动注明 <code>inout</code>，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>fn swap(inout lhs: Int, inout rhs: Int):
</span></span><span style=display:flex><span>    let tmp <span style=color:#f92672>=</span> lhs
</span></span><span style=display:flex><span>    lhs <span style=color:#f92672>=</span> rhs
</span></span><span style=display:flex><span>    rhs <span style=color:#f92672>=</span> tmp
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fn test_swap():
</span></span><span style=display:flex><span>    var x <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>
</span></span><span style=display:flex><span>    var y <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>
</span></span><span style=display:flex><span>    print(x, y)  <span style=color:#75715e>#&gt; 42, 12</span>
</span></span><span style=display:flex><span>    swap(x, y)
</span></span><span style=display:flex><span>    print(x, y)  <span style=color:#75715e>#&gt; 12, 42</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test_swap()
</span></span></code></pre></div><p>按道理说，Mojo 应该像 Rust 一样规避一个变量同时被可变和不可变借用，也应该规避同时被可变借用，但目前 Mojo 编译器似乎还没实现这一特性，例如下面的代码还是能编译通过的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>var x <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>
</span></span><span style=display:flex><span>swap(x, x)
</span></span></code></pre></div><p>从这也可以看出 Mojo 确实还处在比较早期的发展阶段。</p><p>另一个重要的内存安全概念是对象的所有权，当一个函数获取了对象的所有权后，调用方就不应该再去使用这个对象了，例如我们实现了一个只支持移动的类型 <code>UniquePtr</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>struct UniquePtr:
</span></span><span style=display:flex><span>    var ptr: Int
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fn __init__(inout self, ptr: Int):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>ptr <span style=color:#f92672>=</span> ptr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fn __moveinit__(inout self, owned existing: Self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>ptr <span style=color:#f92672>=</span> existing<span style=color:#f92672>.</span>ptr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fn __del__(owned self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>ptr <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>同时，我们有两个函数，其中，<code>use_ptr</code> 使用了前面提到的 <code>borrow</code> 关键字，借用了 <code>UniquePtr</code> 对象，而 <code>take_ptr</code> 则使用 <code>owned</code> 关键字，指明它需要获取传入对象的所有权。那么，在调用 <code>take_ptr</code> 的时候，我们就需要在参数后面加上 <code>^</code> 后缀，用来表明我们将所有权转移给 <code>take_ptr</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>fn use_ptr(borrowed p: UniquePtr):
</span></span><span style=display:flex><span>    print(p<span style=color:#f92672>.</span>ptr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fn take_ptr(owned p: UniquePtr):
</span></span><span style=display:flex><span>    print(p<span style=color:#f92672>.</span>ptr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fn test_ownership():
</span></span><span style=display:flex><span>    let p <span style=color:#f92672>=</span> UniquePtr(<span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>    use_ptr(p)    <span style=color:#75715e>#&gt; 100</span>
</span></span><span style=display:flex><span>    take_ptr(p<span style=color:#f92672>^</span>)  <span style=color:#75715e>#&gt; 100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test_ownership()
</span></span></code></pre></div><p>因此，如果我们将 <code>use_ptr</code> 和 <code>take_ptr</code> 的调用顺序调换一下，就会出现编译错误：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>fn test_ownership():
</span></span><span style=display:flex><span>    let p <span style=color:#f92672>=</span> UniquePtr(<span style=color:#ae81ff>100</span>)
</span></span><span style=display:flex><span>    take_ptr(p<span style=color:#f92672>^</span>)
</span></span><span style=display:flex><span>    use_ptr(p)    <span style=color:#75715e># ERROR!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test_ownership()
</span></span><span style=display:flex><span><span style=color:#75715e># error: Expression [13]:23:12: use of uninitialized value &#39;p&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#    use_ptr(p) # ERROR: p is no longer valid here!</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#            ^</span>
</span></span></code></pre></div><p>Mojo 的另一个强大之处在与它让对 <a href=https://en.wikipedia.org/wiki/MLIR_(software)>MLIR</a> 的操作变得更简单。MLIR 全称是 Multi-Level Intermediate Representation，是一个编译器开发框架，它存在的目的是通过定义多种方言来逐级将代码转换为机器码，以降低编译器的开发成本。在 MLIR 之前，一个广为人熟知的 IR 是 LLVM IR，一个语言的编译器作者可以通过将自己的语言编译为 LLVM IR 来接入 LLVM 的工具链，使得编译器作者不需要关心底层具体硬件的差别，实现了对底层编译工具链的复用 <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>：</p><p><img src=/images/languages_to_LLVM_IR.png alt="languages to LLVM IR"></p><p>但 LLVM IR 层级过低，难以进行特定于语言本身的优化，从上面的图中也能看出，各个语言为了实现语言本身的优化，都在编译为 LLVM IR 之前加入了自己的 IR。另外 LLVM IR 扩展起来也非常困难，难以适应复杂异构计算的要求，而异构计算在 AI 开发中又非常普遍。MLIR 相比与之前的 IR，更加模块化，仅保留了一个非常小的内核，方便开发者进行扩展。很多编译器将代码编译为 MLIR，而 Mojo 提供了直接访问 MLIR 的能力，这使得 Mojo 能够受益于这些工具。更多关于 MLIR 的内容可以参考这一系列文章：<a href=https://www.lei.chat/zh/posts/compilers-and-irs-llvm-ir-spirv-and-mlir/>编译器与中间表示: LLVM IR, SPIR-V, 以及 MLIR</a>，这里就不作过多赘述，我们主要关注在 Mojo 中可以如何操作 MLIR。举例而言，如果我们希望实现一个新的 boolean 类型 <code>OurBool</code>，我们可以这样实现 <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>alias OurTrue: OurBool <span style=color:#f92672>=</span> __mlir_attr<span style=color:#f92672>.</span><span style=color:#960050;background-color:#1e0010>`</span>true<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>alias OurFalse: OurBool <span style=color:#f92672>=</span> __mlir_attr<span style=color:#f92672>.</span><span style=color:#960050;background-color:#1e0010>`</span>false<span style=color:#960050;background-color:#1e0010>`</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>@register_passable</span>(<span style=color:#e6db74>&#34;trivial&#34;</span>)
</span></span><span style=display:flex><span>struct OurBool:
</span></span><span style=display:flex><span>    var value: __mlir_type<span style=color:#f92672>.</span>i1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fn __init__() <span style=color:#f92672>-&gt;</span> Self:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> OurFalse
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fn __init__(value: __mlir_type<span style=color:#f92672>.</span>i1) <span style=color:#f92672>-&gt;</span> Self:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Self {value: value}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    fn __bool__(self) <span style=color:#f92672>-&gt;</span> Bool:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Bool(self<span style=color:#f92672>.</span>value)
</span></span></code></pre></div><p>这里定义了一个类型为 <code>OurBool</code> 的类型，里面有一个直接使用 MLIR 内置类型 <code>i1</code> 的成员 <code>value</code> <sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup>。在 Mojo 中，我们可以通过 <code>__mlir_type.typename</code> 的形式来访问 MLIR 类型。接着，我们为这个类型提供了两个构造函数，默认情况下构造为 <code>OurFalse</code> 也可基于传入的参数进行构建。最下面的 <code>__bool__</code> 也和 Python 的 <code>__bool__</code> 一样，用于使该类型具有和内置 boolean 类型的性质，此时我们可以这样使用它：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>let t: OurBool <span style=color:#f92672>=</span> OurTrue
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> t: print(<span style=color:#e6db74>&#34;true&#34;</span>)  <span style=color:#75715e>#&gt; true</span>
</span></span></code></pre></div><p>除了使用 MLIR 之外，Mojo 甚至可以允许开发者使用 MLIR 实现逻辑，例如下面的代码中通过应用 MLIR 的 <code>index.casts</code> <sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup> 操作来实现类型转换，然后再通过 <code>index.cmp</code> <sup id=fnref:8><a href=#fn:8 class=footnote-ref role=doc-noteref>8</a></sup> 对值进行比较：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>struct OurBool:
</span></span><span style=display:flex><span>    <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>    fn __eq__(self, rhs: OurBool) <span style=color:#f92672>-&gt;</span> Self:
</span></span><span style=display:flex><span>        let lhsIndex <span style=color:#f92672>=</span> __mlir_op<span style=color:#f92672>.</span><span style=color:#960050;background-color:#1e0010>`</span>index<span style=color:#f92672>.</span>casts<span style=color:#960050;background-color:#1e0010>`</span>[_type : __mlir_type<span style=color:#f92672>.</span>index](
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        let rhsIndex <span style=color:#f92672>=</span> __mlir_op<span style=color:#f92672>.</span><span style=color:#960050;background-color:#1e0010>`</span>index<span style=color:#f92672>.</span>casts<span style=color:#960050;background-color:#1e0010>`</span>[_type : __mlir_type<span style=color:#f92672>.</span>index](
</span></span><span style=display:flex><span>            rhs<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Self(
</span></span><span style=display:flex><span>            __mlir_op<span style=color:#f92672>.</span><span style=color:#960050;background-color:#1e0010>`</span>index<span style=color:#f92672>.</span>cmp<span style=color:#960050;background-color:#1e0010>`</span>[
</span></span><span style=display:flex><span>                pred : __mlir_attr<span style=color:#f92672>.</span><span style=color:#960050;background-color:#1e0010>`</span><span style=color:#75715e>#index&lt;cmp_predicate eq&gt;`</span>
</span></span><span style=display:flex><span>            ](lhsIndex, rhsIndex)
</span></span><span style=display:flex><span>        )
</span></span></code></pre></div><p>基于封装好的 <code>__eq__</code> 方法，我们可以很容易实现 <code>__invert__</code> 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>struct OurBool:
</span></span><span style=display:flex><span>    <span style=color:#75715e># ...</span>
</span></span><span style=display:flex><span>    fn __invert__(self) <span style=color:#f92672>-&gt;</span> Self:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> OurFalse <span style=color:#66d9ef>if</span> self <span style=color:#f92672>==</span> OurTrue <span style=color:#66d9ef>else</span> OurTrue
</span></span></code></pre></div><p>此时，我们就可以对 <code>OurBool</code> 类型的对象使用 <code>~</code> 操作符了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>let f <span style=color:#f92672>=</span> OurFalse
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#f92672>~</span>f: print(<span style=color:#e6db74>&#34;false&#34;</span>)  <span style=color:#75715e>#&gt; false</span>
</span></span></code></pre></div><p>通过这个简单的例子我们可以看出，在 Mojo 中，开发者可以通过访问 MLIR 来实现和内置类型同等高效的类型。这使得开发者可以在 Mojo 上为新硬件的数据类型封装高效简单的 Mojo 接口而不需要切换语言。虽然大部分开发者并不需要接触 MLIR，但 Mojo 为更深入和更底层的优化提供了充分的可能性。</p><h2 id=总结为-ai-而生而不止于-ai>总结：为 AI 而生而不止于 AI
<a href=#%e6%80%bb%e7%bb%93%e4%b8%ba-ai-%e8%80%8c%e7%94%9f%e8%80%8c%e4%b8%8d%e6%ad%a2%e4%ba%8e-ai class=h-anchor aria-hidden=true>#</a></h2><p>虽然 Mojo 反复强调它是为 AI 设计的新语言，但以目前 Mojo 的设计方向来看，它的发展前景并不止于 AI。本质上 Mojo 提供了一个能够兼容 Python 生态的高性能语言，且这个语言可以让 Python 开发者几乎无痛地切换过去，那 Python 开发者何乐而不为呢？对于使用 Mojo 的开发者来说，上层业务可以将 Mojo 当 Python 一样使用，享受到简明的语法带来的高开发效率，当出现性能瓶颈的时候，也不用切换语言去进行优化，直接使用 Mojo 重构模块即可。虽然现在还没法在生产环境中验证这个想法，但这个未来听起来确实非常美好。关于 Mojo 和 Python 开发性能的对比，还可以通过 Mojo 发布会上播放的 <a href="https://www.youtube.com/watch?v=6GvB5lZJqcE">Jeremy Howard demo for Mojo launch</a> 这个视频来感受一下。</p><p>目前 Mojo 还在比较早期的阶段，不仅许多语言特性都还没实现，而且连本地开发的套件都没有提供。不过其发展路线和设计思路都非常务实 <sup id=fnref:9><a href=#fn:9 class=footnote-ref role=doc-noteref>9</a></sup>，又有一个足够专业的领导者和公司作为背景支撑，可以说是未来可期，也非常希望这个语言能在其他领域得到更广泛的应用。</p><h2 id=references>References
<a href=#references class=h-anchor aria-hidden=true>#</a></h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://www.modular.com/mojo>Mojo🔥 Homepage - Modular</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://en.wikipedia.org/wiki/Chris_Lattner>Chris Lattner - Wikipedia</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://xkcd.com/353/>Python - XKCD</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://arxiv.org/abs/2002.11054>MLIR: A Compiler Infrastructure for the End of Moore&rsquo;s Law - Chris Lattner</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://docs.modular.com/mojo/notebooks/BoolMLIR.html>Low-level IR in Mojo - Modular</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><a href=https://mlir.llvm.org/docs/Dialects/Builtin/#integertype>Dialects#Builtin#IntegerType - MLIR</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/#indexcasts-mlirindexcastsop>Dialects#IndexOps#IncexCasts - MLIR</a>&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:8><p><a href=https://mlir.llvm.org/docs/Dialects/IndexOps/#indexcmp-mlirindexcmpop>Dialects#IndexOps#IncexCmp - MLIR</a>&#160;<a href=#fnref:8 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:9><p><a href=https://docs.modular.com/mojo/roadmap.html>Mojo🔥 roadmap & sharp edges - Modular</a>&#160;<a href=#fnref:9 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button next"><a href=/posts/unreal-skeletal-animation-source-code/><span class=button__text>Unreal 骨骼动画源码剖析</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class="copyright copyright--user"><p>本网站采用 <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a> 协议进行授权</p><p>© 2023 Zhirui Li. All rights reserved.</p></div></div></footer><script src=/assets/main.js></script>
<script src=/assets/prism.js></script></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-80302213-1","auto"),ga("send","pageview"))</script></body></html>