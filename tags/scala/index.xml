<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Scala on 简单易懂的现代魔法</title><link>/tags/scala/</link><description>Recent content in Scala on 简单易懂的现代魔法</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>&lt;p>本网站采用 &lt;a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0&lt;/a> 协议进行授权&lt;/p>&lt;p>© 2021 Zhirui Li. All rights reserved.&lt;/p></copyright><lastBuildDate>Sun, 02 Oct 2016 00:00:00 +0000</lastBuildDate><atom:link href="/tags/scala/index.xml" rel="self" type="application/rss+xml"/><item><title>不可变的状态</title><link>/posts/immutable-state/</link><pubDate>Sun, 02 Oct 2016 00:00:00 +0000</pubDate><guid>/posts/immutable-state/</guid><description>
可变与状态 在过程式的编程中，例如使用 C 语言，我们的工作是不断地以副作用的形式对状态进行修改，然后产生结果。例如我们可能会先令 int x = 0，然后进行一系列操作，将 x 修改以记录这些操作的过程和产生的效果，最后再产生结果。但是，如果一个语言建议一个值不可变（例如 Scala）或是强制要求一个值不可变（例如 Haskell）那又该怎么办？
例如说我们想要实现这样的一个函数，这个函数将遍历一棵二叉树，并给其每一个树叶打上标签 1，二叉树的定义如下：
sealed trait Tree[A] case class Leaf[A](value: A) extends Tree[A] case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A] 如果我们传递给 labelTree 函数一棵
val tree = Branch(Leaf(&amp;#39;a&amp;#39;), Branch(Branch(Leaf(&amp;#39;b&amp;#39;), Leaf(&amp;#39;c&amp;#39;)), Leaf(&amp;#39;d&amp;#39;))) 这样的树，我们想要得到这样的结果：
Branch(Leaf((0,&amp;#39;a&amp;#39;)),Branch(Branch(Leaf((1,&amp;#39;b&amp;#39;)),Leaf((2,&amp;#39;c&amp;#39;))),Leaf((3,&amp;#39;d&amp;#39;)))) 这显然是一个涉及读写状态的问题，当函数决定给一个节点进行标记的时候，它必须需要知道当前应该打什么标签，并且用某种方法影响下一个节点所要被打的标签。一个简单的处理如下：
var i = 0 def labelTree[A](tree: Tree[A]): Tree[(Int, A)] = tree match { case Leaf(value) =&amp;gt; val newLeaf = Leaf(i, value) i += 1 newLeaf case Branch(left, right) =&amp;gt; Branch(labelTree(left), labelTree(right)) } 这个处理很简单直接，就是维护一个变量 i，当函数 labelTree 遍历一棵树的时候，如果看到了叶子节点，就打上标签 i 并将 i 加 1。如果看到一个树枝节点，就先递归标记左子树，然后再递归标记右子树，并用这两个结果构筑新树。使用方法如下：</description></item><item><title>Parser Combinator</title><link>/posts/parser-combinator/</link><pubDate>Sat, 10 Sep 2016 00:00:00 +0000</pubDate><guid>/posts/parser-combinator/</guid><description>
词法分析和语法分析 词法分析（lexical analysis）1 和语法分析（syntactic analysis，又称为 parsing）2，同属于编译器的前端部分。词法分析器（lexer）将输入拆分为一个个的 token，然后语法分析器根据特定的语法规则将输入的 token 解析为一个结构化的表示，一般为抽象语法树（abstract syntax tree），供之后的语义分析器使用。
在实际开发中，为了简化写词法分析和语法分析的过程，常常会使用生成器来代替人工操作，Lex 和 Yacc 就是生成器的经典实现 3。Lex 是 Lexical Analyzer 的简写，是一个词法分析器的生成器，Yacc 是 Yet Another Compiler Compiler 的简写，是一个语法分析器的生成器。这两个工具允许用户用类似 BNF 范式的写法声明一个词法描述和语法描述文件，然后自动生成能够解析对应词法语法的 C 语言程序。
这个解决方案直观有效，实际应用也很普遍，不止是 C 语言，在其他平台也常有类似的实现，例如 Java 的 ANTLR。但是它也存在一些问题，首先是用机器生成的代码质量往往不如手写高。这个代码质量的问题在程序正常运作的时候倒也不算什么问题，毕竟可以将生成出来的代码当作一个黑盒来调用，不太需要理会内部的实现，但实际情况有时并不这么理想，如果描述的时候出现问题怎么办？甚至如果生成器本身就有 bug 又怎么办？由于生成出来的代码质量较低，所以这就带来了调试困难的问题。所以，在很多重要的应用中，parser 的部分往往是手写的而非用生成器生成 4。不过手写解析器毕竟会有代码不直观的问题，而且这个过程往往比较枯燥乏味。
也就是说，我们希望有一个方法，能够使得我们在用某种规范形式描述出一个语言的语法后，就能构造出针对该语言的词法分析器和语法分析器，且这个特性必须要尽可能不损失可调试性，同时又足够简单易用。
使用 Parser Combinator 解析文本 Parser combinator 5 也许是对上述问题的一个比较好的回答，虽然 parser combinator 也有不少缺点使得它解析复杂语法的时候往往力不从心，但在简单的情况下还是比较好用的，另外其中反映的编程思想也相当有趣。
举个例子，在 Java 中，bool 类型的字面值写法有 true 和 false 两种，用 BNF 范式表述大概是这样：
bool_literal ::= &amp;quot;true&amp;quot; | &amp;quot;false&amp;quot; 如果使用 Haskell 的 Megaparsec 6 来写，就可以写成这样：</description></item><item><title>使用 Future 进行并发编程</title><link>/posts/handle-concurrency-using-future/</link><pubDate>Sat, 27 Aug 2016 00:00:00 +0000</pubDate><guid>/posts/handle-concurrency-using-future/</guid><description>
Future 的概念 在编程的时候，常常会遇到需要并行处理一些代码，最原始的做法就是创建不同的线程进行处理，但是线程之间的同步处理非常麻烦而且容易出错，如果要同时得到几个线程的结果并且通过这些结果进行进一步的计算，则需要共享变量或者进行线程间通信，无论如何都非常难以处理。另外，直接使用线程也使得代码灵活性不高，比如在双核机器上可能只希望使用两个线程执行代码，到了四核机器上就希望最多能有四个线程了。Future 能够提供一个高层的抽象，将计算任务的并发化和计算最终的执行方式分离，使得这类处理更为方便。Future 作为一个代理对象代表一个可能完成也可能未完成的值 1，通过对 future 进行操作，能够获取内部的计算是否已经完成，是否出现异常，计算结果是什么等信息。
Java 中的 Future Java 很早就提供了 Future 接口 2，使用起来大概是这样的：
interface ArchiveSearcher { String search(String target); } class App { ExecutorService executor = ... ; // init executor service ArchiveSearcher searcher = ... ; // init searcher void showSearch(final String target) throws InterruptedException { Future&amp;lt;String&amp;gt; future = executor.submit(new Callable&amp;lt;String&amp;gt;() { public String call() { return searcher.search(target); } }); displayOtherThings(); // do other things while searching try { displayText(future.</description></item><item><title>Null 值及其处理方式</title><link>/posts/null-value-and-handling/</link><pubDate>Fri, 22 Jul 2016 00:00:00 +0000</pubDate><guid>/posts/null-value-and-handling/</guid><description>
Null 值由来已久，它最早是由 Tony Hoare 图方便而创造的，后来被证明这是个错误，而他本人也对此进行了道歉，并称之为「十亿美金错误」1。
I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&amp;rsquo;t resist the temptation to put in a null reference, simply because it was so easy to implement.</description></item><item><title>协变、逆变与不变</title><link>/posts/covariant-and-contravariant/</link><pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate><guid>/posts/covariant-and-contravariant/</guid><description>
型变（variance）是类型系统里的概念，包括协变（covariance）、逆变（contravariance）和不变（invariance）。这组术语的目的是描述泛型情况下类型参数的父子类关系如何影响参数化类型的父子类关系。也就是说，假设有一个接收一个类型参数的参数化类型 T 和两个类 A，B，且 B 是 A 的子类，那么 T[A] 与 T[B] 的关系是什么？如果 T[B] 是 T[A] 的子类，那么这种型变就是「协变」，因为参数化类型 T 的父子类关系与其类型参数的父子类关系是「同一个方向的」。如果 T[A] 是 T[B] 的子类，则这种关系是「逆变」，因为参数化类型 T 的父子类关系与类型参数的父子类关系是「相反方向的」。类似地，如果 T[A] 和 T[B] 之间不存在父子类关系，那么这种型变就是「不变」1。
协变 在 Java 中，数组是协变的，也就是说，假设有一个基类 Person 和一个 Person 的子类 Student。因为 Student 类型是 Person 类型的子类，所以 Student[] 类型是 Person[] 类型的子类，这个设计似乎相当符合直觉，一个学生（Student）是一个人（Person），那一个存放着学生的数组当然也应该是一个存放着人的数组了。
然而这是错误的。
假设 Person 有另一个子类 Teacher，考虑如下代码：
Student[] students = { new Student() } students[0].study(); Person[] persons = students; persons[0] = new Teacher(); students[0].study(); // Oops! 这段代码显然错了，看一下刚刚做了什么。我们在 Student 数组里存放了一个 Student 实例，紧接着调用了这个对象的 study 方法，这个显然没错；然后将这个数组赋值给一个 Person 数组，由于数组是协变的，所以这步没问题；然后，向 Person 数组里添加一个 Teacher 的实例，这步也没问题，因为一个 Teacher 是一个 Person；接下来是获取 Student 数组里的对象，调用 Student 类的 study 方法，这似乎也是合理的。那问题在哪呢？</description></item></channel></rss>