<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Functional Programming on 简单易懂的现代魔法 - Zhirui Li</title><link>https://zhiruili.github.io/tags/functional-programming/</link><description>Recent content in Functional Programming on 简单易懂的现代魔法 - Zhirui Li</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 02 Oct 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://zhiruili.github.io/tags/functional-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>不可变的状态</title><link>https://zhiruili.github.io/posts/2016-10-02-immutable-state/</link><pubDate>Sun, 02 Oct 2016 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/2016-10-02-immutable-state/</guid><description>可变与状态 在过程式的编程中，例如使用 C 语言，我们的工作是不断地以副作用的形式对状态进行修改，然后产生结果。例如我们可能会先令 int x = 0，然后进行一系列操作，将 x 修改以记录这些操作的过程和产生的效果，最后再产生结果。但是，如果一个语言建议一个值不可变（例如 Scala）或是强制要求一个值不可变（例如 Haskell）那又该怎么办？
例如说我们想要实现这样的一个函数，这个函数将遍历一棵二叉树，并给其每一个树叶打上标签 1，二叉树的定义如下：
sealed trait Tree[A] case class Leaf[A](value: A) extends Tree[A] case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A] 如果我们传递给 labelTree 函数一棵
val tree = Branch(Leaf(&amp;#39;a&amp;#39;), Branch(Branch(Leaf(&amp;#39;b&amp;#39;), Leaf(&amp;#39;c&amp;#39;)), Leaf(&amp;#39;d&amp;#39;))) 这样的树，我们想要得到这样的结果：
Branch(Leaf((0,&amp;#39;a&amp;#39;)),Branch(Branch(Leaf((1,&amp;#39;b&amp;#39;)),Leaf((2,&amp;#39;c&amp;#39;))),Leaf((3,&amp;#39;d&amp;#39;)))) 这显然是一个涉及读写状态的问题，当函数决定给一个节点进行标记的时候，它必须需要知道当前应该打什么标签，并且用某种方法影响下一个节点所要被打的标签。一个简单的处理如下：
var i = 0 def labelTree[A](tree: Tree[A]): Tree[(Int, A)] = tree match { case Leaf(value) =&amp;gt; val newLeaf = Leaf(i, value) i += 1 newLeaf case Branch(left, right) =&amp;gt; Branch(labelTree(left), labelTree(right)) } 这个处理很简单直接，就是维护一个变量 i，当函数 labelTree 遍历一棵树的时候，如果看到了叶子节点，就打上标签 i 并将 i 加 1。如果看到一个树枝节点，就先递归标记左子树，然后再递归标记右子树，并用这两个结果构筑新树。使用方法如下：</description></item><item><title>Parser Combinator</title><link>https://zhiruili.github.io/posts/2016-09-10-parser-combinator/</link><pubDate>Sat, 10 Sep 2016 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/2016-09-10-parser-combinator/</guid><description>词法分析和语法分析 词法分析（lexical analysis）1 和语法分析（syntactic analysis，又称为 parsing）2，同属于编译器的前端部分。词法分析器（lexer）将输入拆分为一个个的 token，然后语法分析器根据特定的语法规则将输入的 token 解析为一个结构化的表示，一般为抽象语法树（abstract syntax tree），供之后的语义分析器使用。
在实际开发中，为了简化写词法分析和语法分析的过程，常常会使用生成器来代替人工操作，Lex 和 Yacc 就是生成器的经典实现 3。Lex 是 Lexical Analyzer 的简写，是一个词法分析器的生成器，Yacc 是 Yet Another Compiler Compiler 的简写，是一个语法分析器的生成器。这两个工具允许用户用类似 BNF 范式的写法声明一个词法描述和语法描述文件，然后自动生成能够解析对应词法语法的 C 语言程序。
这个解决方案直观有效，实际应用也很普遍，不止是 C 语言，在其他平台也常有类似的实现，例如 Java 的 ANTLR。但是它也存在一些问题，首先是用机器生成的代码质量往往不如手写高。这个代码质量的问题在程序正常运作的时候倒也不算什么问题，毕竟可以将生成出来的代码当作一个黑盒来调用，不太需要理会内部的实现，但实际情况有时并不这么理想，如果描述的时候出现问题怎么办？甚至如果生成器本身就有 bug 又怎么办？由于生成出来的代码质量较低，所以这就带来了调试困难的问题。所以，在很多重要的应用中，parser 的部分往往是手写的而非用生成器生成 4。不过手写解析器毕竟会有代码不直观的问题，而且这个过程往往比较枯燥乏味。
也就是说，我们希望有一个方法，能够使得我们在用某种规范形式描述出一个语言的语法后，就能构造出针对该语言的词法分析器和语法分析器，且这个特性必须要尽可能不损失可调试性，同时又足够简单易用。
使用 Parser Combinator 解析文本 Parser combinator 5 也许是对上述问题的一个比较好的回答，虽然 parser combinator 也有不少缺点使得它解析复杂语法的时候往往力不从心，但在简单的情况下还是比较好用的，另外其中反映的编程思想也相当有趣。
举个例子，在 Java 中，bool 类型的字面值写法有 true 和 false 两种，用 BNF 范式表述大概是这样：
bool_literal ::= &amp;quot;true&amp;quot; | &amp;quot;false&amp;quot; 如果使用 Haskell 的 Megaparsec 6 来写，就可以写成这样：</description></item><item><title>计算的表示</title><link>https://zhiruili.github.io/posts/2016-07-08-representation-of-calculation/</link><pubDate>Fri, 08 Jul 2016 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/2016-07-08-representation-of-calculation/</guid><description>当提到「计算」这个词的时候，我们会想到什么，是想到「计算机」，或是「图灵机」，又或是操控计算机的「汇编语言」，还是说「1 + 1」这样的算式？这些都是计算，但它们都是计算的一种表示而非计算本身，计算本身是一个更加本质的东西，可以认为是一种柏拉图型相，或是理念，刚刚说到的东西都是对它的摹仿。
比如我们说到「4」的时候，我们在用「4」这个符号去摹仿「4」这个理念，这个理念可以用「4」来摹仿，也可以用「四」，也可以用「four」，具体是什么不重要，重要的是你不会走在路上突然见到一个「4」，而是会见到一个类似「4」的东西。那既然可以用这样一个来自阿拉伯的符号来摹仿数字，那是否有其他的方式来摹仿呢？更一般地说，是否有其他的计算表示方式，并以此来实现我们在汇编语言，C，Java，等语言中表示的计算呢？下面将介绍一个图灵完备的计算模型，称为 λ 演算（lambda calculus）1，该计算的表示由 Alonzo Church 在 20 世纪 30 年代发明，它可被称为是最小的通用程序设计语言。
λ 演算 λ 演算非常简练，而且相对于图灵机的计算模型来说非常优雅，其核心在于表达式（expression）。一个名字（name）又被称为变量（variable），是一个标识符（identifier），可以是任意的字母，如：a, b, c 等。而表达式的定义如下：
$$ \begin{array}{rcl} \text{(expression)} &amp;amp; := &amp;amp; \text{(name) | (function) | (application)} \newline \text{(function)} &amp;amp; := &amp;amp; \lambda~\text{(name).(expression)} \newline \text{(application)} &amp;amp; := &amp;amp; \text{(expression)(expression)} \newline \end{array} $$
至于变换规则则总共有三条，更加具体的描述可参考维基百科 2：
α - conversion: 改变绑定变量的名称不影响函数本身；β - reduction: 将函数应用于其参数；η - conversion: 两个函数对于所有的参数得到的结果都一致，当且仅当它们是同一个函数。
本文后面的部分均使用 Scheme 语言来描述这些计算，在 Scheme 中，有非常类似 λ 演算中表达式的表示，例如一个函数 $\lambda x.y$ 将在 Scheme 中表示为 (lambda (x) y)，而将函数应用于参数 $x~y$ 将在 Scheme 中表示为 (x y)。最大的区别可能在于，在 λ 演算中，(x) 和 x 一样，而在 Scheme 中，前者会变成一个对函数 x 的调用，而后面则是 x 本身。</description></item></channel></rss>