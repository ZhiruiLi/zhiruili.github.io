<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lisp on 简单易懂的现代魔法 - Zhirui Li</title><link>https://zhiruili.github.io/tags/lisp/</link><description>Recent content in Lisp on 简单易懂的现代魔法 - Zhirui Li</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 25 Mar 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://zhiruili.github.io/tags/lisp/index.xml" rel="self" type="application/rss+xml"/><item><title>静态作用域和动态作用域</title><link>https://zhiruili.github.io/posts/dynamic-scope/</link><pubDate>Sat, 25 Mar 2017 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/dynamic-scope/</guid><description>静态作用域和动态作用域 所谓作用域规则就是程序解析名字的方法。如果一个变量的名称不在当前作用域内，则这样的变量称为 unbound variable，例如有一个函数 (lambda () (+ a a))，a 就是一个 unbound variable，在当前作用域内我们无法找到这个变量。那么调用这个函数的求值结果是什么呢？显然要根据 context 来确定，对于 unbound variables 的解析，从解析的时机来划分，有两种规则，一种是「静态作用域」（Static Scope）也被称为「词法作用域」（Lexical Scope），另一种是「动态作用域」（Dynamic Scope）1。
对于现在流行的大多数语言来说，其作用域规则都是静态作用域规则，例如 Java、C++ 等，其特点根据函数定义处的环境解析里面用到的 unbound variables。仅有少数语言使用动态作用域规则，例如 Emacs Lisp，其函数内的 unbound variables 的解析是根据函数被调用时的环境来决定的。举例而言，对如下的表达式求值：
1 2 3 4 (let ((a 1)) (let ((doubleA (lambda () (+ a a)))) (let ((a 2)) (doubleA)))) 如果采用静态作用域规则，这个表达式的值为 2，而如果采用动态作用域规则，其值则为 4。原因是当 doubleA 被定义时，可以在外层作用域找到 a = 1。而对于采用动态作用域的语言来说，a 的查找并不是在 doubleA 被定义的时候，而是在 doubleA 被调用的地方，此时 a = 2。当然，采用动态作用域规则的语言也会不断向外层作用域寻找名字，所以对下面这个表达式求值，无论是采用静态作用域规则还是动态作用域规则，其结果都是 2：
1 2 3 (let ((a 1)) (let ((doubleA (lambda () (+ a a)))) (doubleA))) 那这两种规则哪种比较好呢？看被语言所采用的比例就知道，显然是静态作用域规则更好。其原因是在采用静态作用域规则的时候，对于函数的定义者来说，他可以通过阅读自己的代码很容易地知道他所使用到的变量当前绑定的具体实体是什么，而在使用采用动态作用域的语言时，则需要考虑这个函数被调用的时候该变量所对应的具体实体，这事实上是一种破坏封装的行为。举个例子，假设我们需要写几个对传入参数加一个数字的函数，例如 (lambda (n) (+ n 1))，那我们可能会希望对这组函数进行一个抽象，构建一个 createAddN 函数：</description></item><item><title>计算的表示</title><link>https://zhiruili.github.io/posts/representation-of-calculation/</link><pubDate>Fri, 08 Jul 2016 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/representation-of-calculation/</guid><description>当提到「计算」这个词的时候，我们会想到什么，是想到「计算机」，或是「图灵机」，又或是操控计算机的「汇编语言」，还是说「1 + 1」这样的算式？这些都是计算，但它们都是计算的一种表示而非计算本身，计算本身是一个更加本质的东西，可以认为是一种柏拉图型相，或是理念，刚刚说到的东西都是对它的摹仿。
比如我们说到「4」的时候，我们在用「4」这个符号去摹仿「4」这个理念，这个理念可以用「4」来摹仿，也可以用「四」，也可以用「four」，具体是什么不重要，重要的是你不会走在路上突然见到一个「4」，而是会见到一个类似「4」的东西。那既然可以用这样一个来自阿拉伯的符号来摹仿数字，那是否有其他的方式来摹仿呢？更一般地说，是否有其他的计算表示方式，并以此来实现我们在汇编语言，C，Java，等语言中表示的计算呢？下面将介绍一个图灵完备的计算模型，称为 λ 演算（lambda calculus）1，该计算的表示由 Alonzo Church 在 20 世纪 30 年代发明，它可被称为是最小的通用程序设计语言。
λ 演算 λ 演算非常简练，而且相对于图灵机的计算模型来说非常优雅，其核心在于表达式（expression）。一个名字（name）又被称为变量（variable），是一个标识符（identifier），可以是任意的字母，如：a, b, c 等。而表达式的定义如下：
$$ \begin{array}{rcl} \text{(expression)} &amp;amp; := &amp;amp; \text{(name) | (function) | (application)} \newline \text{(function)} &amp;amp; := &amp;amp; \lambda~\text{(name).(expression)} \newline \text{(application)} &amp;amp; := &amp;amp; \text{(expression)(expression)} \newline \end{array} $$
至于变换规则则总共有三条，更加具体的描述可参考维基百科 2：
α - conversion: 改变绑定变量的名称不影响函数本身；β - reduction: 将函数应用于其参数；η - conversion: 两个函数对于所有的参数得到的结果都一致，当且仅当它们是同一个函数。
本文后面的部分均使用 Scheme 语言来描述这些计算，在 Scheme 中，有非常类似 λ 演算中表达式的表示，例如一个函数 $\lambda x.y$ 将在 Scheme 中表示为 (lambda (x) y)，而将函数应用于参数 $x~y$ 将在 Scheme 中表示为 (x y)。最大的区别可能在于，在 λ 演算中，(x) 和 x 一样，而在 Scheme 中，前者会变成一个对函数 x 的调用，而后面则是 x 本身。</description></item></channel></rss>