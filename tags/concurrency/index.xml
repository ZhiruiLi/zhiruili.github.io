<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concurrency on 简单易懂的现代魔法 - Zhirui Li</title><link>https://zhiruili.github.io/tags/concurrency/</link><description>Recent content in Concurrency on 简单易懂的现代魔法 - Zhirui Li</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 17 May 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://zhiruili.github.io/tags/concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>[译] Apple 官方指南 - Dispatch Queues</title><link>https://zhiruili.github.io/posts/translation-dispatch-queues/</link><pubDate>Wed, 17 May 2017 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/translation-dispatch-queues/</guid><description>Grand Central Dispatch（GCD）分派队列（dispatch queues）是一个用于处理任务（tasks）的强大工具。分派队列让你能够异步（asynchronously）或同步地（synchronously）执行任意的代码块（blocks of code）。你可以使用分派队列来处理几乎所有的可放在不同线程中处理的任务。使用分派队列的优点在于它们相对于直接使用线程来说要更加易用且更加高效。
本章将介绍分派队列，并提供了关于如何在自己的应用程序中用它们来执行一般任务的参考。如果你希望将当前直接使用线程的代码改为使用分派队列，你可以在 Migrating Aray from Threads 里找到一些额外的提示。
关于分派队列 分派队列能简化异步并发（concurrently）处理任务的过程。所谓任务就是指你的应用程序中需要处理的一些工作。例如定义一个任务用来处理一些计算、创建或修改一个数据结构、从一个文件中读取数据或者做其他的事情。定义一个任务的方式是将相应的代码放进一个函数（function）或者一个块对象（block object）中并将其添加进一个分派队列。
分派队列是一个类似于对象的结构，它负责管理你向它提交的任务。所有的分派队列都是一个先入先出的数据结构。所以，你添加进队列的任务的开始顺序都和添加顺序一样。GCD 自动提供了一些分派队列，你也可以根据特定的需求创建其他的分派队列。表 1 列出了你能在应用程序中获取到的分派队列以及你使用它们的方式。
表 1：分派队列的类型
类型 描述 串行（Serial） 串行队列（又被称为私有分派队列（private dispatch queues））在同一时间内只会执行一个任务，并且执行的顺序是你向该队列添加任务的顺序。当前正在执行的任务运行于一个特定的线程中（不同任务可能会运行于不同的线程中），该过程由分派队列进行管理。串行队列常常被用来同步对特定资源的访问。你可以根据你的需要创建任意数量的串行队列，每一个串行队列的操作是与其他队列并发进行的。换句话说，如果你创建了四个串行队列，每一个队列在同一时间内只执行一个任务，但仍然可能最多有四个任务并发执行，每一个任务都来自单独的一个队列。参看「创建串行分派队列」一节以获取关于如何创建串行队列的信息。 并发（Concurrent） 并发队列（又被称为一种全局分派队列（a type of global dispatch queue））并发地执行一个或多个任务，但是任务仍然按照它们被添加进队列的顺序来启动。并发执行的任务运行于不同的线程中，该过程由分派队列来进行管理。在每一个时间点执行的具体任务数是可变的，具体数量取决于系统的状况。在 iOS 5 或之后的版本中，你可以通过将队列类型设置为 DISPATCH_QUEUE_CONCURRENT 来创建自己的并发分派队列。不仅如此，系统还提供了四个预定义的全局并发队列供你的应用程序使用。参看「获取全局并发分派队列」一节以获取更多关于如何获取全局并发队列的信息。 主分派队列（ Main dispatch queue） 主分派队列是一个全局的串行分派队列，它在应用程序的主线程中执行任务。该队列和应用程序的运行循环（run loop)（如果有的话）协同工作，将排队中的任务和其他的事件源交错放入运行循环中。因为主队列在你的应用程序的主线程中执行任务，所以它常常被用作一个应用程序的关键同步点。尽管你不需要创建一个主分派队列，然而你需要确保你的应用程序合理地声明了（drains）它。参看「在主线程中处理任务」一节以获取关于该队列是如何被管理的信息。 当涉及到提高一个应用程序并发性的时候，分派队列相对于线程来说有几个优势。最直接的优势就是工作队列编程模型较为简单。使用线程的时候，你需要同时写两部分的代码，一个是待处理工作的代码，另一个是创建和管理线程的代码。分派队列则让你专注于你要处理的工作，系统帮助你处理所有线程的创建和管理工作，使你不需要担心线程的创建和管理。这里有一个优势在于系统可以比单个应用程序更加高效地管理线程，系统能够根据可用资源和当前系统的状态动态地增减线程数量。不仅如此，系统还常常能比你自己创建线程时更加快速地开始运行你的任务。
尽管你可能认为将你的代码重写为使用分派队列的形式会比较困难，但事实上写使用分派队列的代码经常比写使用线程的代码简单。写这样的代码的关键在于设计自包含的（self-contained）能异步执行的独立任务。（事实上无论是使用分派队列还是直接使用线程，你都应该这样设计。）分派队列的一个优势是它的可预测性。如果你有两个运行于不同线程的任务访问同一个资源，其中任意一个线程可能先修改该资源，此时你会需要用一个锁来确保这两个任务不会同时修改该资源。如果你使用了分派队列来实现这一逻辑，你可以将这两个任务添加到一个串行队列中以确保在任意给定时间内，只有一个任务在修改该资源。这种基于分派队列的同步比使用锁要更加高效，因为锁无论是在争用还是在无争用的情况下都需要进行一个代价高昂的内核陷阱中断，而分派队列则主要工作在应用程序的进程空间里，只有当必须要陷入内核的时候才会陷入内核。
你也许会指出，两个运行于一个串行队列中的任务并没有并发地运行，尽管这是对的，但你要记住，如果两个线程在争用一个锁，那么任何线程提供的并发性都会失去或是大幅减少。更重要的是，线程编程模型需要创建两个线程，这需要申请内核和用户空间的内存。分派队列则不需要付出这种创建线程的内存代价，它们使用的线程总是处于占用状态并且不会阻塞。
关于分派队列，你需要记住一些关键点：
一个分派队列与其他分派队列并发地执行任务。任务的顺序性只限于单个分派队列内。 在任意时间执行任务的总数由系统决定。所以，如果一个应用程序将 100 个任务放进 100 个不同的分派队列中，那么这些任务并不一定会并发地执行（除非有 100 个或者更多个可用的核）。 系统在选择开始一个新的任务的时候会考虑队列的优先级。参看「向分派队列提供一个清理函数」一节以获取有关如何设置串行队列的优先级的信息。 队列中的任务必须在它被添加进队列的时候就要作好被调用的准备。（如果你曾经用过 Cocoa 操作对象（Cocoa operation objects），注意该行为与模型操作不同。） 私有分派队列是引用计数的对象。除了在你自己的代码中保持（retain）对队列的引用，你还需要注意分派源也可以被加入到一个队列中，这也会增加其保持计数。所以，你必须确保所有分派源都被取消了（canceled）且每一个保持调用都有一个合适的释放（release）调用与之平衡。参看「分派队列的内存管理」一节以获取更多有关保持和释放队列的信息。参看 About Dispatch Sources 以获取更多关于分派源的信息。 参看 Grand Central Dispatch (GCD) Reference（注：原链接失效，这里替换了另一个链接）以获取更多有关分派队列的操作接口的信息。</description></item><item><title>使用 Future 进行并发编程</title><link>https://zhiruili.github.io/posts/handle-concurrency-using-future/</link><pubDate>Sat, 27 Aug 2016 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/handle-concurrency-using-future/</guid><description>Future 的概念 在编程的时候，常常会遇到需要并行处理一些代码，最原始的做法就是创建不同的线程进行处理，但是线程之间的同步处理非常麻烦而且容易出错，如果要同时得到几个线程的结果并且通过这些结果进行进一步的计算，则需要共享变量或者进行线程间通信，无论如何都非常难以处理。另外，直接使用线程也使得代码灵活性不高，比如在双核机器上可能只希望使用两个线程执行代码，到了四核机器上就希望最多能有四个线程了。Future 能够提供一个高层的抽象，将计算任务的并发化和计算最终的执行方式分离，使得这类处理更为方便。Future 作为一个代理对象代表一个可能完成也可能未完成的值 1，通过对 future 进行操作，能够获取内部的计算是否已经完成，是否出现异常，计算结果是什么等信息。
Java 中的 Future Java 很早就提供了 Future 接口 2，使用起来大概是这样的：
interface ArchiveSearcher { String search(String target); } class App { ExecutorService executor = ... ; // init executor service ArchiveSearcher searcher = ... ; // init searcher void showSearch(final String target) throws InterruptedException { Future&amp;lt;String&amp;gt; future = executor.submit(new Callable&amp;lt;String&amp;gt;() { public String call() { return searcher.search(target); } }); displayOtherThings(); // do other things while searching try { displayText(future.</description></item></channel></rss>