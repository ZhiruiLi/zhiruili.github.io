<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Object-oriented Programming on 简单易懂的现代魔法 - Zhirui Li</title><link>https://zhiruili.github.io/tags/object-oriented-programming/</link><description>Recent content in Object-oriented Programming on 简单易懂的现代魔法 - Zhirui Li</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 14 Jul 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://zhiruili.github.io/tags/object-oriented-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>协变、逆变与不变</title><link>https://zhiruili.github.io/posts/covariant-and-contravariant/</link><pubDate>Thu, 14 Jul 2016 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/covariant-and-contravariant/</guid><description>型变（variance）是类型系统里的概念，包括协变（covariance）、逆变（contravariance）和不变（invariance）。这组术语的目的是描述泛型情况下类型参数的父子类关系如何影响参数化类型的父子类关系。也就是说，假设有一个接收一个类型参数的参数化类型 T 和两个类 A，B，且 B 是 A 的子类，那么 T[A] 与 T[B] 的关系是什么？如果 T[B] 是 T[A] 的子类，那么这种型变就是「协变」，因为参数化类型 T 的父子类关系与其类型参数的父子类关系是「同一个方向的」。如果 T[A] 是 T[B] 的子类，则这种关系是「逆变」，因为参数化类型 T 的父子类关系与类型参数的父子类关系是「相反方向的」。类似地，如果 T[A] 和 T[B] 之间不存在父子类关系，那么这种型变就是「不变」1。
协变 在 Java 中，数组是协变的，也就是说，假设有一个基类 Person 和一个 Person 的子类 Student。因为 Student 类型是 Person 类型的子类，所以 Student[] 类型是 Person[] 类型的子类，这个设计似乎相当符合直觉，一个学生（Student）是一个人（Person），那一个存放着学生的数组当然也应该是一个存放着人的数组了。
然而这是错误的。
假设 Person 有另一个子类 Teacher，考虑如下代码：
1 2 3 4 5 Student[] students = { new Student() } students[0].study(); Person[] persons = students; persons[0] = new Teacher(); students[0].</description></item></channel></rss>