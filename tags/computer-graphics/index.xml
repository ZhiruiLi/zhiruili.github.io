<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer Graphics on 简单易懂的现代魔法</title><link>/tags/computer-graphics/</link><description>Recent content in Computer Graphics on 简单易懂的现代魔法</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>&lt;p>本网站采用 &lt;a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0&lt;/a> 协议进行授权&lt;/p>&lt;p>© 2021 Zhirui Li. All rights reserved.&lt;/p></copyright><lastBuildDate>Sat, 07 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="/tags/computer-graphics/index.xml" rel="self" type="application/rss+xml"/><item><title>深入理解渲染方程</title><link>/posts/rendering-equation/</link><pubDate>Sat, 07 Aug 2021 00:00:00 +0000</pubDate><guid>/posts/rendering-equation/</guid><description>
在图形学入门（三）：基础着色中，我们讨论了 Phong 反射模型，当时我们提到过 Phong 反射模型不是一个物理模型，而是一个经验模型，这意味着这个模型对光照效果的模拟是不准确的。即便在简单情况下它能近似出一些不错的效果，但随着场景的复杂度提升（例如复杂的光照、复杂的材质等），要想继续用 Phong 反射模型达到很强的真实感就变得越来越困难。例如下面的这幅图 1 中，士兵和长官的铠甲上都投影出了电梯里非常复杂的灯光，在后面的长官的铠甲上还能看到前面两个士兵的投影：
要想在计算机中模拟出这样真实的效果，我们首先要知道真实世界中的光线和物体是如何作用的，例如一束光线照射到物体表面，这束光线的量有多少，光线照射到物体表面后发生了什么，最后光线反射的方向和量又有多少，我们用什么物理单位来衡量这些量等等。这些准确定义的信息是计算出正确的结果的前提，只有先理解这些内容，我们才能更好地模拟光与物体相互作用的过程。
接下来我们会讨论关于辐射度量学（Radiometry）2 的内容，这是一个研究各种电磁辐射强弱的学科。在本文后面我们将会看到，基于辐射度量学构建的渲染方程（Rendering Equation）3 可以准确描述光如何在场景中流动，并在理论上给出了一个完美的结果。而各种各样的渲染技术，就是这个理想结果的一个近似。事实上，只要涉足高质量的实时渲染，渲染方程几乎是绕不开的前置知识。深入理解渲染方程包含的物理意义可以使我们更好地学习高质量真实感渲染的进阶内容。
在正式开始讨论前，我们首先明确要讨论的对象，也就是光的性质。我们知道，光其实有波粒二象性 4，但我们后面的讨论会基于几何光学 5，既不考虑其波动性，也不考虑其粒子性，仍然认为光沿直线传播。
辐射度量学 辐射通量（Radiant Flux） 让我们从最简单的物理量开始讨论，辐射能（Radiant Energy）6 $Q$ 是指电磁辐射具有的能量，它的单位是焦耳 $\mathrm{J}$。能量这个概念我们很熟悉，但是它在我们的讨论中几乎用不上，我们更关心的是单位时间的能量，也就是功率（Power）。在辐射度量学中，我们一般称其为辐射通量（Radiant Flux）7 $\Phi$，单位是瓦特 $\mathrm{W}$。
$$ \Phi \equiv \frac{\mathrm{d} Q}{\mathrm{d} t} $$
我们更关心单位时间的能量而不是总能量是很符合常理的，例如一个电灯打开的时间越长肯定辐射出的光的总能量越多，但我们关心的主要还是这个灯有多亮，这也就是单位时间的光的能量。
辐射通量是辐射度量学中最基本的物理量。一个表面的辐射通量可以用「通过」该表面的坡印廷向量（Poynting Vector）8 $S$ 表示（这也是为什么要叫「通量」）。所谓坡印廷向量其实就是有向的能量流，它的方向为电磁能的传递方向，大小为能量密度（单位面积的能量传输速率）。在我们的讨论里，我们认为它是光线就可以了。设所求表面的表面法线为 $\hat{n}$，表面面积为 $A$，$\hat{n}$ 和 $S$ 的夹角为 $\theta$，那么表面 $\sigma$ 的辐射通量可以表示为：
$$ \Phi = \int_{\sigma} S \cdot \hat{n} \ \mathrm{d} A = \int_{\sigma} \left| S \right| \cos{} \theta \ \mathrm{d} A $$
有没有觉得这个说法听起来很熟悉？没错，这正是我们在图形学入门（三）：基础着色中计算漫反射分量时提到的内容。当时我们通过下图 9 直观了解入射光和表面法线存在 $\theta$ 夹角时，漫反射能量的减少情况：</description></item><item><title>图形学入门（三）：基础着色</title><link>/posts/basic-shading/</link><pubDate>Sun, 01 Aug 2021 00:00:00 +0000</pubDate><guid>/posts/basic-shading/</guid><description>
在掌握了上一篇文章的知识之后，我们现在可以通过逐个绘制三角形面组合出一个模型了。但是我们现在绘制出来的结果看起来是一个色块，效果不太自然。在现实中，我们看到物体是因为这个物体反射了光线，而在这个过程中，根据物体形状以及与光线的相对位置关系，物体的表面总会呈现不同的明暗效果。这种明暗的变化使我们感觉这个物体是「立体的」。也就是说，我们更希望看到下图 1 中右侧的渲染效果而非左侧的渲染效果：
在计算机图形学中，着色（Shading）1 表示在三维场景中基于模型表面与光源的角度、与光源的距离、与相机的角度等因素，来改变多边形颜色的过程，以此来生成具有真实感的效果。这里说的「真实感」是指类似照片拍摄的效果。
Phong 反射模型 真实的符合物理规律的光照极其复杂，想要在计算机中正确模拟出这个效果非常困难。为了能在计算机中快速进行渲染，我们需要采用一些方法简化这个计算过程，现在被广泛使用的着色模型叫 Phong 反射模型（Phong Reflection Model）2。这个模型对现实中光照反射规律进行近似模拟，将物体对光线的反射拆成三个分量，分别是：漫反射光（Diffuse）、镜面高光（Specular）和环境光（Ambient）。在后面的讨论中我们会看到，这个模型本身虽然不是一个物理模型而是一个经验模型，但它也符合一些基本的物理规律，并可以很好地模拟相当广泛的视觉场景。
Phong 反射模型基于这样的观察：
一个物体表面越粗糙，其对光线的反射就越分散，而这部分反射的光构成了物体本身的基础颜色，这部分颜色用漫反射分量 $L_d$ 表示 一个物体表面越光滑，其对光线的反射就越集中，就越会在某些位置上呈现比较集中明亮的高光，这部分颜色用镜面反射分量 $L_s$ 表示 如果场景中有光源，那么即便一个物体没有直接被光源照亮，我们也还是看到这个物体。事实上，这部分表面接收到了来自四面八方的间接光照，这部分颜色用环境光分量 $L_a$ 表示 这个观察基本上也符合我们的认知，而这三个分量叠加的效果看起来还是相当可信的，如下图所示 2：
需要说明的是，Phong 反射模型是一个局部模型，所谓「局部」是指，在计算某个点（我们称之为着色点）的颜色时我们只考虑这个点本身的属性以及这个点和光线的关系，和其他物体无关。「非局部」的典型例子就是阴影，阴影的计算不仅需要考虑当前着色点，还需要考虑着色点与光源之间的遮挡物。因此 Phong 反射模型的计算中并不会产生阴影。具体来说，我们在计算一个点的颜色时，我们可用的局部信息有如下几部分：
观察方向 $\hat{v}$ 每个光源的方向 $\hat{l}$ 当前点的表面法线方向 $\hat{n}$ 当前点的表面材质参数（例如颜色、光泽度等） 其中，$\hat{v}$、$\hat{l}$、$\hat{n}$ 都是单位向量。
漫反射分量 我们知道，一个粗糙的物体表面会将入射的光向周围各个方向反射，我们称之为漫反射，如下图 3 所示：
我们前面提到，漫反射的分量构成了物体的整体颜色，它是 Phong 反射模型中最重要的一部分。我们知道，物体表面呈现不同的颜色是由于不同的表面会吸收不同波长的光并反射其他的光，我们用漫反射系数 $k_d$ 描述这种现象，如果 $k_d = 1$，那么物体本身不吸收对应颜色的光，对其进行完全的反射，如果为 $0$，那么说明完全吸收了对应颜色的光。而这个入射的光，我们则用 $I$ 表示。另外根据我们日常的观察也会发现，如果一个表面正对着光源，那么这个表面看起来就会比较亮，如果背对光源，这个表面看起来就会比较暗。如下图 3 所示，当一个物体表面正对光源时，它能接收到光源的全部能量，当它没有正对光源时，接收到的能量就变少了。这个能量的具体比例可以用平面法线方向 $\hat{n}$ 和光源方向 $\hat{l}$ 的夹角 $\theta$ 的余弦值来确定：
又由于 $\hat{n}$ 和 $\hat{l}$ 是单位向量，我们可以直接对其进行点乘来获取到这个余弦值，因此，我们的漫反射分量 $L_d$ 表示如下：</description></item><item><title>图形学入门（二）：光栅化</title><link>/posts/rasterization/</link><pubDate>Sun, 25 Jul 2021 00:00:00 +0000</pubDate><guid>/posts/rasterization/</guid><description>
光栅化（Rasterize）就是将一些矢量形状转换为位图（Raster Image）形式。经过这样的变换后，这些形状才可以在屏幕上进行显示，也可以被打印机打印出来。
之所以需要这么做，是因为我们的屏幕其实可以被看做一个像素（Pixel）的点阵，程序通过设置每个像素点展示的颜色来展示整体的图像。而我们在计算机中描述一个模型的时候，往往使用了这些模型的顶点坐标来进行描述，例如一个三角形的三个顶点是：$(0,\ 0,\ 0)$、$(0,\ 1,\ 0)$ 和 $(1,\ 0,\ 0)$。那么，在一个 $1920 \times 1080$ 的屏幕上，应该把哪些像素点亮来展示这个三角形呢？这个信息模型本身并没有告诉我们，这就存在一个信息的不匹配，因此我们需要光栅化这一步来将这个图形展示出来。
可以顺便一提的是，「Pixel」是 Picture Element 的缩写，翻译成「像素」相当准确，而「Raster」其实是德语的「屏幕」，所谓「Rasterize」直译过来就是「在屏幕上绘制」。本来非常简单清晰的原意被翻译作「光栅化」，导致这个名字听起来有点吓人。
为了方便后续的讨论，在正式开始之前，我们还需要先声明一些前提条件。一般来说，屏幕上的每个像素并不是一个不可分割的点，但是在我们后续讨论的过程中，认为像素就是屏幕显示的最小单位，一个像素中只能展示一个完整的颜色。而我们认为屏幕就是一个二维的像素数据的数组，大小为 $width \times height$，左下角的坐标为 $(0,\ 0)$，每个像素的宽度为 $1$，任意的一个像素 $(x,\ y)$ 的中心位置在 $(x + 0.5,\ y + 0.5)$ 上，如下图 1 中蓝色的像素的坐标就是 $(2,\ 1)$，其中心点的位置就是 $(2.5,\ 1.5)$。我们要做的，就是将上一篇文章中压缩到标准正方体中的图形绘制到这样的目标上：
为了操作屏幕上的像素点，我们需要申请一个长度为 $width \times height$ 的数组，数组中的每一个元素都是一个色彩值，一一对应于屏幕上的像素点。然后，我们将绘制的数据记录在这个缓冲区域中，待设置好后再将数据绘制到屏幕上。这块缓冲区域被称为帧缓冲（Frame Buffer）2。
绘制线段 让我们先从绘制图形的线框开始，线框的绘制其实就是分别绘制模型的每一条边对应的线段。为了在屏幕上绘制一条线段，我们首先需要计算出线段两个端点坐标在屏幕的位置。在标准正方体内的顶点的 $x$、$y$ 坐标的范围都是 $[-1,\ 1]$，假设我们有一个 $width \times height$ 分辨率的屏幕，我们就需要将其分别变为 $[0,\ width]$ 和 $[0,\ height]$。根据上一篇文章的知识，我们可以很容易知道，我们只需要对顶点坐标应用如下的矩阵变换，就能得到顶点在屏幕空间下的坐标了：
$$ M_{viewport} = \begin{bmatrix} \frac{width}{2} &amp;amp; 0 &amp;amp; 0 &amp;amp; \frac{width}{2} \newline 0 &amp;amp; \frac{height}{2} &amp;amp; 0 &amp;amp; \frac{height}{2} \newline 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \newline 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{bmatrix} $$</description></item><item><title>图形学入门（一）：坐标变换</title><link>/posts/transformations/</link><pubDate>Sat, 17 Jul 2021 00:00:00 +0000</pubDate><guid>/posts/transformations/</guid><description>
将一个物体显示到屏幕上，这个事情似乎非常简单，以至于我们基本上认为它已经天经地义到直接告诉计算机我们要显示什么物体它就会自动显示出来，毕竟我们拍照的时候就是举起相机按下快门就会出现一张图片了。但事实上，相机是基于物理感光元件实现了从三维世界到二维图片的投影，在计算机的程序世界中一切都需要被计算出来，也就是说，我们只有一堆图形的描述信息，我们需要自己将这些图形在二维的平面上绘制的方式告诉操作系统，操作系统才能最终在屏幕上绘制出我们想要的图形。
那么，我们究竟要进行怎样的一些计算呢？我们可以将这个过程和拍照进行类比，物体的位置、角度，相机的位置、角度以及相机本身设置的一些参数都会对拍照的结果产生影响，相机离物体近，物体就显得大一些，相机往左偏，物体在最终相片上的位置就会往右。显然，光有场景中物体本身的模型信息还不足以让我们知道最终呈现在屏幕上的图像的样子，我们还需要考虑上述的种种信息才能最终得出在二维的平面上这个场景最终的形态，这些计算主要分为三部分：
模型空间到世界空间的变换
这个过程将物体的每个顶点坐标从自己模型空间移动到世界空间，也就是将物体移动到世界的对应位置摆放好。
世界空间到观察空间的变换
这个过程将物体的每个顶点坐标从世界空间移动到相机的观察空间，由于位置的移动是相对的，这也就相当于把相机移动到对应位置摆放好。只不过为了计算方便，我们一般假设相机的位置就在原点的位置，看向 $z$ 轴负方向。
观察空间到裁剪空间的变换
这个过程就是将物体的每个顶点坐标从三维空间投影到相机的二维成像平面上，这也就相当于相机拍照时在胶片上记录下当时的画面。
数学基础 为了说明这三种变换在计算机中是如何进行的，这里需要先补充一点相关的基础知识。在计算机中，为了进行快速的计算，采用了矩阵（Matrix）这一数学工具。下面是一个 $3 \times 2$ 的矩阵（即 $3$ 行 $2$ 列的矩阵）：
$$ A = \begin{bmatrix} 1 &amp;amp; 2 \newline 3 &amp;amp; 4 \newline 5 &amp;amp; 6 \end{bmatrix} $$
矩阵有一个操作叫转置（Transpose），矩阵 $A$ 的转置写作 $A^\mathrm{T}$，这个过程其实就是将矩阵沿着左上到右下的对角线翻转，即把 $A$ 的每一行写 $A^\mathrm{T}$ 的列，把 $A$ 的每一列写 $A^\mathrm{T}$ 的行，对于上面的矩阵 $A$ 来说，我们有：
$$ A^\mathrm{T} = \begin{bmatrix} 1 &amp;amp; 3 &amp;amp; 5 \newline 2 &amp;amp; 4 &amp;amp; 6 \end{bmatrix} $$</description></item></channel></rss>