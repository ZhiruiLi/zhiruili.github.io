<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on 简单易懂的现代魔法 - Zhirui Li</title><link>https://zhiruili.github.io/categories/notes/</link><description>Recent content in Notes on 简单易懂的现代魔法 - Zhirui Li</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 01 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://zhiruili.github.io/categories/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Unity 和 Android 的工程集成</title><link>https://zhiruili.github.io/posts/unity-with-android/</link><pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/unity-with-android/</guid><description>有时候，我们需要在 Unity 里调用一些 Android 的功能，这些功能在 Unity 中可能并没有提供接口，需要在 Android 平台上实现。此时，我们需要有一个方法来让 Android 代码和 Unity 代码互交互。这里记录一下操作方法，并提供一个工具来简化两个工程之间的集成流程。
示例工程 下面的记录中所使用的工程可以参考 UnityAndroidExample。其中，根目录是 Unity 工程，可以直接用 Unity 打开。根目录下的 AndroidSample 子目录是 Android 工程，可以用 Android Studio 打开。
Unity 工程运行后如下图左所示，只有一个文本和一个按钮，点击按钮就会触发 Unity 到 Anrdoid 的调用，在主界面上产生一个 toast，同时，触发一次从 Anrdoid 到 Unity 的调用，主界面上的文本变为「Hello From Android」：
具体操作方式 新建一个 Android 工程 这里随便用 Android Studio 建立空一个工程就行了。建立好工程后，参考官方文档在工程里添加一个自定义的模块：
菜单栏点击 「File」-「New」-「New Module&amp;hellip;」 弹出窗口中左侧选「Android Library」 右侧填入相关信息后创建模块 假设创建的模块名为「mod」，那么就会在工程根目录下新增一个名为 mod 的目录。此时可以删除工程根目录中默认创建的 app 目录，并将工程根目录中 settings.gradle 文件里的 include ':app' 这一行删除。
添加 Unity jar 依赖 为了在 Android 中和 Unity 互交互，我们需要引入 Unity 提供的库，这个库以 jar 包的形式提供。以下目录中都有这个 classes.</description></item><item><title>错误使用 C++ 模板特化产生的坑</title><link>https://zhiruili.github.io/posts/cpp-template-specialization/</link><pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/cpp-template-specialization/</guid><description>今天在群里看到了一个错误使用 C++ 模板特化产生的坑，有点意思，这里记录一下。
问题是这样的：
有一个名为 A 的库，包含如下的头文件 a.h 和代码文件 a.cc
1 2 3 4 5 6 7 8 9 10 11 12 13 // a.h #pragma once #include &amp;lt;iostream&amp;gt;template &amp;lt;class T&amp;gt; struct A { void print() { std::cout &amp;lt;&amp;lt; &amp;#34;normal&amp;#34; &amp;lt;&amp;lt; std::endl; } }; // a.cc #include &amp;#34;a.h&amp;#34;template &amp;lt;&amp;gt; void A&amp;lt;int&amp;gt;::print() { std::cout &amp;lt;&amp;lt; &amp;#34;specialization&amp;#34; &amp;lt;&amp;lt; std::endl; } 有如下代码文件 main.cc 使用了这个库：
1 2 3 4 5 #include &amp;#34;a.</description></item><item><title>Prometheus 上报和查询</title><link>https://zhiruili.github.io/posts/prometheus-report-query/</link><pubDate>Fri, 02 Oct 2020 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/prometheus-report-query/</guid><description>基本概念 采样样本 Prometheus 会定期去对数据进行采集，每一次采集的结果都是一次采样的样本（sample），这些数据会被存储为时间序列，也就是带有时间戳的 value stream，这些 value stream 归属于自己的监控指标。
这里采集样本包括了三部分：
监控指标（metric） 毫秒时间戳（timestamp） 样本的值（value） 监控指标 一个监控指标被表示为下面的格式：
metric_name { label_name_1=label_value_1, label_name_2=label_value_2, ... } 这里的 metric_name 用于指明监控的内容，label_value_x 则用于声明这个监控内容中不同维度的值。用我们常见的二维坐标系举例，下面有一个二维坐标系，名称为「xxx 坐标系」，其中，有 X，Y 两个轴，上面有两个点，分别是 A 和 B，它们的坐标分别为 (1, 3) 和 (2, 1)：
xxx坐标系 Y ^ │ . A (1, 3) │ │ . B (2, 1) v &amp;lt;-----------------&amp;gt; X 对应于 Prometheus，这里的 metric_name 就是 「xxx 坐标系」，label_name_1 就是 X，label_name_2 就是 Y。需要注意的是，这里的 A 和 B 两个点并不代表采样点，而是监控指标。我们可以想象在这个图中还存在一条虚拟的时间轴，分别从 A B 两点从屏幕外垂直屏幕进去，在这两条虚拟的时间轴上，每一个点就是一个采样点，采样点上会带一个毫秒时间戳和一个值，这个值就是样本的值。在 Prometheus 中，样本的值必须为 float64 类型的值。</description></item><item><title>Android 动画笔记</title><link>https://zhiruili.github.io/posts/android-animation/</link><pubDate>Tue, 25 Jul 2017 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/android-animation/</guid><description>动画分类 属性动画 Property Animation
最为方便强大，推荐使用。
视图动画 View Animation
旧版本的动画方式。
绘制动画 Drawable Animation
即一帧帧绘制画面，万能但仅在必要时使用。
属性动画和视图动画的区别 视图动画只能作用于 View 对象，属性动画没有这个限制。 视图动画只能操纵少数几个属性，例如缩放比例、旋转角度等，许多属性，例如背景颜色，就没法通过视图动画进行操作，属性动画更加通用。 视图动画仅仅修改了绘制位置，并没有实际修改属性值，例如用视图动画实现一个按钮移动的效果，按钮可以正确移动，但是用户点按按钮的位置却没有改变。 属性动画相对于视图动画而言要复杂一些，对于一些简单情形可以考虑用视图动画解决。 属性动画 属性动画几乎可以实现任何想要的动画效果，非常具有可扩展性并且非常稳健。属性动画可供设定的选项包括了：
持续时间（默认 300 ms）
时间插值（Time interpolation）
即指定一个关于时间的函数，使得属性值的计算依赖于这个函数。
重复播放、逆向播放
动画集合
可以将一组动画合并成一个集合，然后同时播放或是顺序播放或是延时播放。
帧刷新间隔
默认是 10 ms，可以改成别的值，但最终取决于系统状态。
属性动画的工作方式 属性动画通过指定一个对象的属性的改变方式来实现动画，举例来说，如果想要实现一个对象在 x 轴上的横向移动动画，那就让这个对象的 x 轴坐标每隔一个时间间隔变化一点即可。例如下图表示了一个对象在 40 ms 内沿 x 轴移动了 40 px 的动画：</description></item><item><title>Java Puzzlers</title><link>https://zhiruili.github.io/posts/java-puzzlers/</link><pubDate>Sun, 07 Aug 2016 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/java-puzzlers/</guid><description>The Joy of Sets 1 2 3 4 5 6 7 8 9 10 public class ShortSet { public static void main(String args[]) { Set&amp;lt;Short&amp;gt; s = new HashSet&amp;lt;Short&amp;gt;(); for (short i = 0; i &amp;lt; 100; i++) { s.add(i); s.remove(i - 1); } } System.out.println(s.size()); } 可能会认为这段代码输出的结果是 1，但实际上这段代码输出的结果是 100。
原因在于当调用 i - 1 时，这个计算结果不是 short 类型，而是 int 类型，当调用 s.remove(i - 1) 时，i - 1 的结果会被自动装箱，成为一个 Integer 类型的对象，而不是 Short 类型的对象，这导致 Set&amp;lt;Short&amp;gt; s 中根本没有要删除的对象，所以会出现 100 这个结果。</description></item></channel></rss>