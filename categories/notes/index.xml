<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>notes on 简单易懂的现代魔法 - Zhirui Li</title><link>https://zhiruili.github.io/categories/notes/</link><description>Recent content in notes on 简单易懂的现代魔法 - Zhirui Li</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 02 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://zhiruili.github.io/categories/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Prometheus 上报和查询</title><link>https://zhiruili.github.io/posts/prometheus-report-query/</link><pubDate>Fri, 02 Oct 2020 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/prometheus-report-query/</guid><description>基本概念 采样样本 Prometheus 会定期去对数据进行采集，每一次采集的结果都是一次采样的样本（sample），这些数据会被存储为时间序列，也就是带有时间戳的 value stream，这些 value stream 归属于自己的监控指标。
这里采集样本包括了三部分：
监控指标（metric） 毫秒时间戳（timestamp） 样本的值（value） 监控指标 一个监控指标被表示为下面的格式：
metric_name { label_name_1=label_value_1, label_name_2=label_value_2, ... } 这里的 metric_name 用于指明监控的内容，label_value_x 则用于声明这个监控内容中不同维度的值。用我们常见的二维坐标系举例，下面有一个二维坐标系，名称为「xxx 坐标系」，其中，有 X，Y 两个轴，上面有两个点，分别是 A 和 B，它们的坐标分别为 (1, 3) 和 (2, 1)：
xxx坐标系 Y ^ │ . A (1, 3) │ │ . B (2, 1) v &amp;lt;-----------------&amp;gt; X 对应于 Prometheus，这里的 metric_name 就是 「xxx 坐标系」，label_name_1 就是 X，label_name_2 就是 Y。需要注意的是，这里的 A 和 B 两个点并不代表采样点，而是监控指标。我们可以想象在这个图中还存在一条虚拟的时间轴，分别从 A B 两点从屏幕外垂直屏幕进去，在这两条虚拟的时间轴上，每一个点就是一个采样点，采样点上会带一个毫秒时间戳和一个值，这个值就是样本的值。在 Prometheus 中，样本的值必须为 float64 类型的值。</description></item><item><title>Android 动画笔记</title><link>https://zhiruili.github.io/posts/android-animation/</link><pubDate>Tue, 25 Jul 2017 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/android-animation/</guid><description>动画分类 属性动画 Property Animation
最为方便强大，推荐使用。
视图动画 View Animation
旧版本的动画方式。
绘制动画 Drawable Animation
即一帧帧绘制画面，万能但仅在必要时使用。
属性动画和视图动画的区别 视图动画只能作用于 View 对象，属性动画没有这个限制。 视图动画只能操纵少数几个属性，例如缩放比例、旋转角度等，许多属性，例如背景颜色，就没法通过视图动画进行操作，属性动画更加通用。 视图动画仅仅修改了绘制位置，并没有实际修改属性值，例如用视图动画实现一个按钮移动的效果，按钮可以正确移动，但是用户点按按钮的位置却没有改变。 属性动画相对于视图动画而言要复杂一些，对于一些简单情形可以考虑用视图动画解决。 属性动画 属性动画几乎可以实现任何想要的动画效果，非常具有可扩展性并且非常稳健。属性动画可供设定的选项包括了：
持续时间（默认 300 ms）
时间插值（Time interpolation）
即指定一个关于时间的函数，使得属性值的计算依赖于这个函数。
重复播放、逆向播放
动画集合
可以将一组动画合并成一个集合，然后同时播放或是顺序播放或是延时播放。
帧刷新间隔
默认是 10 ms，可以改成别的值，但最终取决于系统状态。
属性动画的工作方式 属性动画通过指定一个对象的属性的改变方式来实现动画，举例来说，如果想要实现一个对象在 x 轴上的横向移动动画，那就让这个对象的 x 轴坐标每隔一个时间间隔变化一点即可。例如下图表示了一个对象在 40 ms 内沿 x 轴移动了 40 px 的动画：</description></item><item><title>[译] Apple 官方指南 - Dispatch Queues</title><link>https://zhiruili.github.io/posts/translation-dispatch-queues/</link><pubDate>Wed, 17 May 2017 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/translation-dispatch-queues/</guid><description>Grand Central Dispatch（GCD）分派队列（dispatch queues）是一个用于处理任务（tasks）的强大工具。分派队列让你能够异步（asynchronously）或同步地（synchronously）执行任意的代码块（blocks of code）。你可以使用分派队列来处理几乎所有的可放在不同线程中处理的任务。使用分派队列的优点在于它们相对于直接使用线程来说要更加易用且更加高效。
本章将介绍分派队列，并提供了关于如何在自己的应用程序中用它们来执行一般任务的参考。如果你希望将当前直接使用线程的代码改为使用分派队列，你可以在 Migrating Aray from Threads 里找到一些额外的提示。
关于分派队列 分派队列能简化异步并发（concurrently）处理任务的过程。所谓任务就是指你的应用程序中需要处理的一些工作。例如定义一个任务用来处理一些计算、创建或修改一个数据结构、从一个文件中读取数据或者做其他的事情。定义一个任务的方式是将相应的代码放进一个函数（function）或者一个块对象（block object）中并将其添加进一个分派队列。
分派队列是一个类似于对象的结构，它负责管理你向它提交的任务。所有的分派队列都是一个先入先出的数据结构。所以，你添加进队列的任务的开始顺序都和添加顺序一样。GCD 自动提供了一些分派队列，你也可以根据特定的需求创建其他的分派队列。表 1 列出了你能在应用程序中获取到的分派队列以及你使用它们的方式。
表 1：分派队列的类型
类型 描述 串行（Serial） 串行队列（又被称为私有分派队列（private dispatch queues））在同一时间内只会执行一个任务，并且执行的顺序是你向该队列添加任务的顺序。当前正在执行的任务运行于一个特定的线程中（不同任务可能会运行于不同的线程中），该过程由分派队列进行管理。串行队列常常被用来同步对特定资源的访问。你可以根据你的需要创建任意数量的串行队列，每一个串行队列的操作是与其他队列并发进行的。换句话说，如果你创建了四个串行队列，每一个队列在同一时间内只执行一个任务，但仍然可能最多有四个任务并发执行，每一个任务都来自单独的一个队列。参看「创建串行分派队列」一节以获取关于如何创建串行队列的信息。 并发（Concurrent） 并发队列（又被称为一种全局分派队列（a type of global dispatch queue））并发地执行一个或多个任务，但是任务仍然按照它们被添加进队列的顺序来启动。并发执行的任务运行于不同的线程中，该过程由分派队列来进行管理。在每一个时间点执行的具体任务数是可变的，具体数量取决于系统的状况。在 iOS 5 或之后的版本中，你可以通过将队列类型设置为 DISPATCH_QUEUE_CONCURRENT 来创建自己的并发分派队列。不仅如此，系统还提供了四个预定义的全局并发队列供你的应用程序使用。参看「获取全局并发分派队列」一节以获取更多关于如何获取全局并发队列的信息。 主分派队列（ Main dispatch queue） 主分派队列是一个全局的串行分派队列，它在应用程序的主线程中执行任务。该队列和应用程序的运行循环（run loop)（如果有的话）协同工作，将排队中的任务和其他的事件源交错放入运行循环中。因为主队列在你的应用程序的主线程中执行任务，所以它常常被用作一个应用程序的关键同步点。尽管你不需要创建一个主分派队列，然而你需要确保你的应用程序合理地声明了（drains）它。参看「在主线程中处理任务」一节以获取关于该队列是如何被管理的信息。 当涉及到提高一个应用程序并发性的时候，分派队列相对于线程来说有几个优势。最直接的优势就是工作队列编程模型较为简单。使用线程的时候，你需要同时写两部分的代码，一个是待处理工作的代码，另一个是创建和管理线程的代码。分派队列则让你专注于你要处理的工作，系统帮助你处理所有线程的创建和管理工作，使你不需要担心线程的创建和管理。这里有一个优势在于系统可以比单个应用程序更加高效地管理线程，系统能够根据可用资源和当前系统的状态动态地增减线程数量。不仅如此，系统还常常能比你自己创建线程时更加快速地开始运行你的任务。
尽管你可能认为将你的代码重写为使用分派队列的形式会比较困难，但事实上写使用分派队列的代码经常比写使用线程的代码简单。写这样的代码的关键在于设计自包含的（self-contained）能异步执行的独立任务。（事实上无论是使用分派队列还是直接使用线程，你都应该这样设计。）分派队列的一个优势是它的可预测性。如果你有两个运行于不同线程的任务访问同一个资源，其中任意一个线程可能先修改该资源，此时你会需要用一个锁来确保这两个任务不会同时修改该资源。如果你使用了分派队列来实现这一逻辑，你可以将这两个任务添加到一个串行队列中以确保在任意给定时间内，只有一个任务在修改该资源。这种基于分派队列的同步比使用锁要更加高效，因为锁无论是在争用还是在无争用的情况下都需要进行一个代价高昂的内核陷阱中断，而分派队列则主要工作在应用程序的进程空间里，只有当必须要陷入内核的时候才会陷入内核。
你也许会指出，两个运行于一个串行队列中的任务并没有并发地运行，尽管这是对的，但你要记住，如果两个线程在争用一个锁，那么任何线程提供的并发性都会失去或是大幅减少。更重要的是，线程编程模型需要创建两个线程，这需要申请内核和用户空间的内存。分派队列则不需要付出这种创建线程的内存代价，它们使用的线程总是处于占用状态并且不会阻塞。
关于分派队列，你需要记住一些关键点：
一个分派队列与其他分派队列并发地执行任务。任务的顺序性只限于单个分派队列内。 在任意时间执行任务的总数由系统决定。所以，如果一个应用程序将 100 个任务放进 100 个不同的分派队列中，那么这些任务并不一定会并发地执行（除非有 100 个或者更多个可用的核）。 系统在选择开始一个新的任务的时候会考虑队列的优先级。参看「向分派队列提供一个清理函数」一节以获取有关如何设置串行队列的优先级的信息。 队列中的任务必须在它被添加进队列的时候就要作好被调用的准备。（如果你曾经用过 Cocoa 操作对象（Cocoa operation objects），注意该行为与模型操作不同。） 私有分派队列是引用计数的对象。除了在你自己的代码中保持（retain）对队列的引用，你还需要注意分派源也可以被加入到一个队列中，这也会增加其保持计数。所以，你必须确保所有分派源都被取消了（canceled）且每一个保持调用都有一个合适的释放（release）调用与之平衡。参看「分派队列的内存管理」一节以获取更多有关保持和释放队列的信息。参看 About Dispatch Sources 以获取更多关于分派源的信息。 参看 Grand Central Dispatch (GCD) Reference（注：原链接失效，这里替换了另一个链接）以获取更多有关分派队列的操作接口的信息。</description></item><item><title>Java Puzzlers</title><link>https://zhiruili.github.io/posts/java-puzzlers/</link><pubDate>Sun, 07 Aug 2016 00:00:00 +0000</pubDate><guid>https://zhiruili.github.io/posts/java-puzzlers/</guid><description>The Joy of Sets public class ShortSet { public static void main(String args[]) { Set&amp;lt;Short&amp;gt; s = new HashSet&amp;lt;Short&amp;gt;(); for (short i = 0; i &amp;lt; 100; i++) { s.add(i); s.remove(i - 1); } } System.out.println(s.size()); } 可能会认为这段代码输出的结果是 1，但实际上这段代码输出的结果是 100。
原因在于当调用 i - 1 时，这个计算结果不是 short 类型，而是 int 类型，当调用 s.remove(i - 1) 时，i - 1 的结果会被自动装箱，成为一个 Integer 类型的对象，而不是 Short 类型的对象，这导致 Set&amp;lt;Short&amp;gt; s 中根本没有要删除的对象，所以会出现 100 这个结果。
但为什么当用户想从一个存放 Short 类型对象的 Set 中移除一个 Integer 类型的对象而编译器并没有报错呢？原因是 Set&amp;lt;T&amp;gt; 提供的接口声明如下：</description></item></channel></rss>