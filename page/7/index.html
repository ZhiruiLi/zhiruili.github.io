<!doctype html><html lang=cn>
<head>
<meta name=generator content="Hugo 0.88.0">
<title>
简单易懂的现代魔法 —
Zhirui Li's Blog
</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Zhirui Li's Blog">
<meta name=keywords content="编程,计算机图形学,游戏开发">
<meta name=robots content="noodp">
<link rel=canonical href=/>
<link rel=stylesheet href=/assets/style.css>
<link rel=stylesheet href=/style.css>
<link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png>
<link rel="shortcut icon" href=/img/favicon.png>
<link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="简单易懂的现代魔法">
<meta name=twitter:description content>
<meta property="og:title" content="简单易懂的现代魔法">
<meta property="og:description" content>
<meta property="og:type" content="website">
<meta property="og:url" content="/"><meta property="og:site_name" content="简单易懂的现代魔法">
<link rel=alternate type=application/rss+xml href=/index.xml title=简单易懂的现代魔法>
<script>var posts=document.getElementById('posts-list');posts&&quicklink({el:posts,priority:!0})</script>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
</head>
<body>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ class=logo style=text-decoration:none>
<span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span>
<span class=logo__text>简单易懂的现代魔法</span>
<span class=logo__cursor></span>
</a>
<span class=header__right>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/archive>Archive</a></li>
<li><a href=https://www.github.com/zhiruili>Github</a></li>
<li><a href=/index.xml>RSS</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/archive>Archive</a></li>
<li><a href=https://www.github.com/zhiruili>Github</a></li>
<li><a href=/index.xml>RSS</a></li>
</ul>
</nav>
<span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span>
<span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg>
</span>
</span>
</span>
</header>
<div class=content>
<div class=posts>
<div class="post on-list">
<h1 class=post-title><a href=/posts/null-value-and-handling/>Null 值及其处理方式</a></h1>
<div class=post-meta>
<span class=post-date>
2016-07-22
</span>
</div>
<span class=post-tags>
<a href=/tags/type-system/>#Type System</a>&nbsp;
<a href=/tags/java/>#Java</a>&nbsp;
<a href=/tags/scala/>#Scala</a>&nbsp;
<a href=/tags/kotlin/>#Kotlin</a>&nbsp;
</span>
<div class=post-content>
Null 值由来已久，它最早是由 Tony Hoare 图方便而创造的，后来被证明这是个错误，而他本人也对此进行了道歉，并称之为「十亿美金错误」1。
I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn&rsquo;t resist the temptation to put in a null reference, simply because it was so easy to implement.
</div>
<div><a class="read-more button" href=/posts/null-value-and-handling/>Read more →</a></div>
</div>
<div class="post on-list">
<h1 class=post-title><a href=/posts/covariant-and-contravariant/>协变、逆变与不变</a></h1>
<div class=post-meta>
<span class=post-date>
2016-07-14
</span>
</div>
<span class=post-tags>
<a href=/tags/type-system/>#Type System</a>&nbsp;
<a href=/tags/scala/>#Scala</a>&nbsp;
<a href=/tags/java/>#Java</a>&nbsp;
</span>
<div class=post-content>
型变（variance）是类型系统里的概念，包括协变（covariance）、逆变（contravariance）和不变（invariance）。这组术语的目的是描述泛型情况下类型参数的父子类关系如何影响参数化类型的父子类关系。也就是说，假设有一个接收一个类型参数的参数化类型 T 和两个类 A，B，且 B 是 A 的子类，那么 T[A] 与 T[B] 的关系是什么？如果 T[B] 是 T[A] 的子类，那么这种型变就是「协变」，因为参数化类型 T 的父子类关系与其类型参数的父子类关系是「同一个方向的」。如果 T[A] 是 T[B] 的子类，则这种关系是「逆变」，因为参数化类型 T 的父子类关系与类型参数的父子类关系是「相反方向的」。类似地，如果 T[A] 和 T[B] 之间不存在父子类关系，那么这种型变就是「不变」1。
协变 在 Java 中，数组是协变的，也就是说，假设有一个基类 Person 和一个 Person 的子类 Student。因为 Student 类型是 Person 类型的子类，所以 Student[] 类型是 Person[] 类型的子类，这个设计似乎相当符合直觉，一个学生（Student）是一个人（Person），那一个存放着学生的数组当然也应该是一个存放着人的数组了。
然而这是错误的。
假设 Person 有另一个子类 Teacher，考虑如下代码：
Student[] students = { new Student() } students[0].study(); Person[] persons = students; persons[0] = new Teacher(); students[0].study(); // Oops! 这段代码显然错了，看一下刚刚做了什么。我们在 Student 数组里存放了一个 Student 实例，紧接着调用了这个对象的 study 方法，这个显然没错；然后将这个数组赋值给一个 Person 数组，由于数组是协变的，所以这步没问题；然后，向 Person 数组里添加一个 Teacher 的实例，这步也没问题，因为一个 Teacher 是一个 Person；接下来是获取 Student 数组里的对象，调用 Student 类的 study 方法，这似乎也是合理的。那问题在哪呢？
</div>
<div><a class="read-more button" href=/posts/covariant-and-contravariant/>Read more →</a></div>
</div>
<div class="post on-list">
<h1 class=post-title><a href=/posts/representation-of-calculation/>计算的表示</a></h1>
<div class=post-meta>
<span class=post-date>
2016-07-08
</span>
</div>
<span class=post-tags>
<a href=/tags/lisp/>#Lisp</a>&nbsp;
</span>
<div class=post-content>
当提到「计算」这个词的时候，我们会想到什么，是想到「计算机」，或是「图灵机」，又或是操控计算机的「汇编语言」，还是说「1 + 1」这样的算式？这些都是计算，但它们都是计算的一种表示而非计算本身，计算本身是一个更加本质的东西，可以认为是一种柏拉图型相，或是理念，刚刚说到的东西都是对它的摹仿。
比如我们说到「4」的时候，我们在用「4」这个符号去摹仿「4」这个理念，这个理念可以用「4」来摹仿，也可以用「四」，也可以用「four」，具体是什么不重要，重要的是你不会走在路上突然见到一个「4」，而是会见到一个类似「4」的东西。那既然可以用这样一个来自阿拉伯的符号来摹仿数字，那是否有其他的方式来摹仿呢？更一般地说，是否有其他的计算表示方式，并以此来实现我们在汇编语言，C，Java，等语言中表示的计算呢？下面将介绍一个图灵完备的计算模型，称为 λ 演算（lambda calculus）1，该计算的表示由 Alonzo Church 在 20 世纪 30 年代发明，它可被称为是最小的通用程序设计语言。
λ 演算 λ 演算非常简练，而且相对于图灵机的计算模型来说非常优雅，其核心在于表达式（expression）。一个名字（name）又被称为变量（variable），是一个标识符（identifier），可以是任意的字母，如：a, b, c 等。而表达式的定义如下：
$$ \begin{array}{rcl} \text{(expression)} & := & \text{(name) | (function) | (application)} \newline \text{(function)} & := & \lambda~\text{(name).(expression)} \newline \text{(application)} & := & \text{(expression)(expression)} \newline \end{array} $$
至于变换规则则总共有三条，更加具体的描述可参考维基百科 2：
α - conversion: 改变绑定变量的名称不影响函数本身；β - reduction: 将函数应用于其参数；η - conversion: 两个函数对于所有的参数得到的结果都一致，当且仅当它们是同一个函数。
本文后面的部分均使用 Scheme 语言来描述这些计算，在 Scheme 中，有非常类似 λ 演算中表达式的表示，例如一个函数 $\lambda x.y$ 将在 Scheme 中表示为 (lambda (x) y)，而将函数应用于参数 $x~y$ 将在 Scheme 中表示为 (x y)。最大的区别可能在于，在 λ 演算中，(x) 和 x 一样，而在 Scheme 中，前者会变成一个对函数 x 的调用，而后面则是 x 本身。
</div>
<div><a class="read-more button" href=/posts/representation-of-calculation/>Read more →</a></div>
</div>
<div class=pagination>
<div class=pagination__buttons>
<span class="button previous">
<a href=/page/6/>
<span class=button__icon>←</span>
<span class=button__text>Newer posts</span>
</a>
</span>
</div>
</div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user"><p>本网站采用 <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a> 协议进行授权</p><p>© 2021 Zhirui Li. All rights reserved.</p></div>
</div>
</footer>
<script src=/assets/main.js></script>
<script src=/assets/prism.js></script><p>我的博客即将同步至腾讯云+社区，<a target=_blank href="https://cloud.tencent.com/developer/support-plan?invite_code=11dehb9vzutlx">邀请大家一同入驻</a>。</p>
</div>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-80302213-1','auto'),ga('send','pageview'))</script>
</body>
</html>