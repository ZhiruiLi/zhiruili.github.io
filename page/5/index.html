<!doctype html><html lang=cn>
<head>
<meta name=generator content="Hugo 0.88.0">
<title>
简单易懂的现代魔法 —
Zhirui Li's Blog
</title>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Zhirui Li's Blog">
<meta name=keywords content="编程,计算机图形学,游戏开发">
<meta name=robots content="noodp">
<link rel=canonical href=/>
<link rel=stylesheet href=/assets/style.css>
<link rel=stylesheet href=/style.css>
<link rel=apple-touch-icon-precomposed sizes=144x144 href=/img/apple-touch-icon-144-precomposed.png>
<link rel="shortcut icon" href=/img/favicon.png>
<link href=/assets/fonts/Inter-Italic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Regular.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Medium.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-MediumItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-Bold.woff2 rel=preload type=font/woff2 as=font crossorigin>
<link href=/assets/fonts/Inter-BoldItalic.woff2 rel=preload type=font/woff2 as=font crossorigin>
<meta name=twitter:card content="summary">
<meta name=twitter:title content="简单易懂的现代魔法">
<meta name=twitter:description content>
<meta property="og:title" content="简单易懂的现代魔法">
<meta property="og:description" content>
<meta property="og:type" content="website">
<meta property="og:url" content="/"><meta property="og:site_name" content="简单易懂的现代魔法">
<link rel=alternate type=application/rss+xml href=/index.xml title=简单易懂的现代魔法>
<script>var posts=document.getElementById('posts-list');posts&&quicklink({el:posts,priority:!0})</script>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script>
</head>
<body>
<div class=container>
<header class=header>
<span class=header__inner>
<a href=/ class=logo style=text-decoration:none>
<span class=logo__mark><svg xmlns="http://www.w3.org/2000/svg" class="greater-icon" viewBox="0 0 44 44"><path fill="none" d="M15 8l14.729 14.382L15 35.367"/></svg>
</span>
<span class=logo__text>简单易懂的现代魔法</span>
<span class=logo__cursor></span>
</a>
<span class=header__right>
<nav class=menu>
<ul class="menu__inner menu__inner--desktop">
<li><a href=/archive>Archive</a></li>
<li><a href=https://www.github.com/zhiruili>Github</a></li>
<li><a href=/index.xml>RSS</a></li>
</ul>
<ul class="menu__inner menu__inner--mobile">
<li><a href=/archive>Archive</a></li>
<li><a href=https://www.github.com/zhiruili>Github</a></li>
<li><a href=/index.xml>RSS</a></li>
</ul>
</nav>
<span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>
</span>
<span class=theme-toggle><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg>
</span>
</span>
</span>
</header>
<div class=content>
<div class=posts>
<div class="post on-list">
<h1 class=post-title><a href=/posts/dynamic-scope/>静态作用域和动态作用域</a></h1>
<div class=post-meta>
<span class=post-date>
2017-03-25
</span>
</div>
<span class=post-tags>
<a href=/tags/c++/>#C++</a>&nbsp;
<a href=/tags/haskell/>#Haskell</a>&nbsp;
<a href=/tags/lisp/>#Lisp</a>&nbsp;
</span>
<div class=post-content>
静态作用域和动态作用域 所谓作用域规则就是程序解析名字的方法。如果一个变量的名称不在当前作用域内，则这样的变量称为 unbound variable，例如有一个函数 (lambda () (+ a a))，a 就是一个 unbound variable，在当前作用域内我们无法找到这个变量。那么调用这个函数的求值结果是什么呢？显然要根据 context 来确定，对于 unbound variables 的解析，从解析的时机来划分，有两种规则，一种是「静态作用域」（Static Scope）也被称为「词法作用域」（Lexical Scope），另一种是「动态作用域」（Dynamic Scope）1。
对于现在流行的大多数语言来说，其作用域规则都是静态作用域规则，例如 Java、C++ 等，其特点根据函数定义处的环境解析里面用到的 unbound variables。仅有少数语言使用动态作用域规则，例如 Emacs Lisp，其函数内的 unbound variables 的解析是根据函数被调用时的环境来决定的。举例而言，对如下的表达式求值：
(let ((a 1)) (let ((doubleA (lambda () (+ a a)))) (let ((a 2)) (doubleA)))) 如果采用静态作用域规则，这个表达式的值为 2，而如果采用动态作用域规则，其值则为 4。原因是当 doubleA 被定义时，可以在外层作用域找到 a = 1。而对于采用动态作用域的语言来说，a 的查找并不是在 doubleA 被定义的时候，而是在 doubleA 被调用的地方，此时 a = 2。当然，采用动态作用域规则的语言也会不断向外层作用域寻找名字，所以对下面这个表达式求值，无论是采用静态作用域规则还是动态作用域规则，其结果都是 2：
(let ((a 1)) (let ((doubleA (lambda () (+ a a)))) (doubleA))) 那这两种规则哪种比较好呢？看被语言所采用的比例就知道，显然是静态作用域规则更好。其原因是在采用静态作用域规则的时候，对于函数的定义者来说，他可以通过阅读自己的代码很容易地知道他所使用到的变量当前绑定的具体实体是什么，而在使用采用动态作用域的语言时，则需要考虑这个函数被调用的时候该变量所对应的具体实体，这事实上是一种破坏封装的行为。举个例子，假设我们需要写几个对传入参数加一个数字的函数，例如 (lambda (n) (+ n 1))，那我们可能会希望对这组函数进行一个抽象，构建一个 createAddN 函数：
</div>
<div><a class="read-more button" href=/posts/dynamic-scope/>Read more →</a></div>
</div>
<div class="post on-list">
<h1 class=post-title><a href=/posts/rust-safety/>Rust 提升安全性的方式</a></h1>
<div class=post-meta>
<span class=post-date>
2017-03-16
</span>
</div>
<span class=post-tags>
<a href=/tags/rust/>#Rust</a>&nbsp;
<a href=/tags/c++/>#C++</a>&nbsp;
</span>
<div class=post-content>
Rust 的起源与目的 Rust 1 是 Mozilla 公司开发的编程语言，它在 2010 才开始发布第一个版本，可以说是一个非常年轻的语言了。在提出一个新的编程语言的时候，设计者必须要回答的一个问题是「为什么要设计这样一个编程语言？」。对于 Rust 来说，他的目的就是要在保证安全的基础上不失对底层的控制力。
注意这里所指的「安全」不是说防止黑客攻击服务器，而是内存安全。拿 Rust 的主要竞争对手 C++ 为例，下面这段代码是安全的吗？
int foo(Bar* pBar) { if (pBar == nullptr) { return -1; } else { return pBar->baz(); } } 显然不是，尽管在 foo 函数中对 pBar 进行了非空的判断，但 pBar 可能指向了一块已经被释放掉了的内存，也就是所谓的「dangling pointer」错误 2，此时程序的行为是未定义的。在 Java 等跑在虚拟机里的语言中，一般会将指针操作隐藏起来，同时由于有 GC 的存在，避免了程序员手动去释放内存，当一个对象不可达的时候，虚拟机会帮程序员去释放掉其占用的内存，所以，这段代码在 Java 中是安全的：
int foo(Bar bar) { if (bar == null) { return -1; } else { return bar.baz(); } } Java 对内存安全的解决方案的问题在于，用户额外增加了虚拟机运行的开销，而且其模型无法做到 C++ 引以为傲的「zero overhead abstraction」。什么叫「zero overhead abstraction」？考虑如下的 C++ 代码：
</div>
<div><a class="read-more button" href=/posts/rust-safety/>Read more →</a></div>
</div>
<div class="post on-list">
<h1 class=post-title><a href=/posts/immutable-state/>不可变的状态</a></h1>
<div class=post-meta>
<span class=post-date>
2016-10-02
</span>
</div>
<span class=post-tags>
<a href=/tags/scala/>#Scala</a>&nbsp;
<a href=/tags/haskell/>#Haskell</a>&nbsp;
</span>
<div class=post-content>
可变与状态 在过程式的编程中，例如使用 C 语言，我们的工作是不断地以副作用的形式对状态进行修改，然后产生结果。例如我们可能会先令 int x = 0，然后进行一系列操作，将 x 修改以记录这些操作的过程和产生的效果，最后再产生结果。但是，如果一个语言建议一个值不可变（例如 Scala）或是强制要求一个值不可变（例如 Haskell）那又该怎么办？
例如说我们想要实现这样的一个函数，这个函数将遍历一棵二叉树，并给其每一个树叶打上标签 1，二叉树的定义如下：
sealed trait Tree[A] case class Leaf[A](value: A) extends Tree[A] case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A] 如果我们传递给 labelTree 函数一棵
val tree = Branch(Leaf('a'), Branch(Branch(Leaf('b'), Leaf('c')), Leaf('d'))) 这样的树，我们想要得到这样的结果：
Branch(Leaf((0,'a')),Branch(Branch(Leaf((1,'b')),Leaf((2,'c'))),Leaf((3,'d')))) 这显然是一个涉及读写状态的问题，当函数决定给一个节点进行标记的时候，它必须需要知道当前应该打什么标签，并且用某种方法影响下一个节点所要被打的标签。一个简单的处理如下：
var i = 0 def labelTree[A](tree: Tree[A]): Tree[(Int, A)] = tree match { case Leaf(value) => val newLeaf = Leaf(i, value) i += 1 newLeaf case Branch(left, right) => Branch(labelTree(left), labelTree(right)) } 这个处理很简单直接，就是维护一个变量 i，当函数 labelTree 遍历一棵树的时候，如果看到了叶子节点，就打上标签 i 并将 i 加 1。如果看到一个树枝节点，就先递归标记左子树，然后再递归标记右子树，并用这两个结果构筑新树。使用方法如下：
</div>
<div><a class="read-more button" href=/posts/immutable-state/>Read more →</a></div>
</div>
<div class=pagination>
<div class=pagination__buttons>
<span class="button previous">
<a href=/page/4/>
<span class=button__icon>←</span>
<span class=button__text>Newer posts</span>
</a>
</span>
<span class="button next">
<a href=/page/6/>
<span class=button__text>Older posts</span>
<span class=button__icon>→</span>
</a>
</span>
</div>
</div>
</div>
</div>
<footer class=footer>
<div class=footer__inner>
<div class="copyright copyright--user"><p>我的博客即将同步至腾讯云+社区，<a target=_blank href="https://cloud.tencent.com/developer/support-plan?invite_code=11dehb9vzutlx">邀请大家一同入驻</a></p><p>本网站采用 <a href=https://creativecommons.org/licenses/by-sa/4.0/>CC BY-SA 4.0</a> 协议进行授权</p></div>
</div>
</footer>
<script src=/assets/main.js></script>
<script src=/assets/prism.js></script>
</div>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-80302213-1','auto'),ga('send','pageview'))</script>
</body>
</html>